{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./doc/js/util.js","webpack:///./node_modules/@emmetio/stream-reader-utils/dist/stream-reader-utils.es.js","webpack:///./node_modules/@emmetio/node/dist/node.es.js","webpack:///./node_modules/@emmetio/stream-reader/dist/stream-reader.es.js","webpack:///./node_modules/@emmetio/abbreviation/dist/abbreviation.es.js","webpack:///./node_modules/@emmetio/html-snippets-resolver/dist/html-snippets-resolver.es.js","webpack:///./node_modules/@emmetio/implicit-tag/dist/implicit-tag.es.js","webpack:///./node_modules/@emmetio/html-transform/dist/html-transform.es.js","webpack:///./node_modules/@emmetio/variable-resolver/dist/variable-resolver.es.js","webpack:///./node_modules/@emmetio/field-parser/dist/field-parser.es.js","webpack:///./node_modules/@emmetio/output-renderer/dist/output-renderer.es.js","webpack:///./node_modules/@emmetio/markup-formatters/dist/markup-formatters.es.js","webpack:///./node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js","webpack:///./node_modules/@emmetio/css-snippets-resolver/dist/css-snippets-resolver.es.js","webpack:///./node_modules/@emmetio/stylesheet-formatters/dist/stylesheet-formatters.es.js","webpack:///./node_modules/@emmetio/snippets/dist/snippets.es.js","webpack:///./node_modules/@emmetio/lorem/dist/lorem.es.js","webpack:///./node_modules/@emmetio/snippets-registry/dist/snippets-registry.es.js","webpack:///./node_modules/@emmetio/output-profile/dist/output-profile.es.js","webpack:///./node_modules/@emmetio/expand-abbreviation/dist/expand.es.js","webpack:///(webpack)/buildin/module.js","webpack:///./src/tinysort.js","webpack:///./test/test-import.js","webpack:///./test/test-jquerywrapper.js","webpack:///./test/test-charorder.js","webpack:///./test/test-regression.js","webpack:///./test/test-api.js","webpack:///./test/test.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","toSlug","str","toLowerCase","replace","a","e","u","-","","replacement","createElement","type","classes","parent","attributes","text","click","mElement","document","attr","setAttribute","oClassList","classList","aArguments","split","add","apply","textContent","addEventListener","appendChild","wrapHTMLString","getFragment","fragment","createDocumentFragment","Array","from","childNodes","forEach","elm","stringToElement","formatSize","number","round","size","aSizes","length","iMult","Math","pow","zen","abbreviation","content","htmlString","_expandAbbreviation","expand","RegExp","clearElement","firstChild","removeChild","loadScript","src","Promise","resolve","reject","script","body","div","innerHTML","SINGLE_QUOTE","DOUBLE_QUOTE","defaultOptions","escape","throws","eatQuoted","stream","options","assign","start","pos","quote","peek","eat","isQuote","eof","next","error","code","isNumber","isAlpha","to","isWhiteSpace","Attribute","[object Object]","this","Node","repeat","selfClosing","children","previous","_attributes","isArray","attributesMap","reduce","out","boolean","isGroup","isTextOnly","lastChild","childIndex","indexOf","nextSibling","previousSibling","getAttribute","filter","uniqueClass","createAttribute","curAttr","replaceAttribute","push","curAttribute","newName","newValue","ix","splice","token","normalize","hasAttribute","hasClass","concat","join","node","insertAt","newNode","refNode","Error","prev","remove","deep","clone","child","fn","_level","ctx","walk","args","arguments","attrs","map","opt","implied","count","String","trim","item","arr","node_es","stream_reader_es","string","end","constructor","charCodeAt","match","ch","ok","substring","slice","message","err","originalMessage","ASTERISK","consumeRepeat","eatWhile","current","consumeQuoted","TEXT_START","TEXT_END","ESCAPE","consumeText","stack","result","offset","fromCharCode","EXCL","DOT","EQUALS","ATTR_OPEN","ATTR_CLOSE","reAttributeName","consumeAttributes","eatUnquoted","test","parseAttributeName","before","after","keys","isUnquoted","isSpace","HASH","DOT$1","SLASH","consumeElement","eatName","addClass","backUp","il","isName","isAlphaNumeric","GROUP_START","GROUP_END","OP_SIBLING","OP_CHILD","OP_CLIMB","unroll","abbreviation_es","abbr","tree","root","groupStack","lastGroup","pop","parse","html_snippets_resolver_es","registry","Set","snippet","has","delete","childTarget","findDeepestNode","classNames","mergeClassNames","attrMap","Map","set","removeAttribute","newAttrs","values","mergeAttributes","merge","insertBefore","resolveNode","inlineElements","elementMap","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","implicit_tag_es","parentName","implicitTags","findUnescapedTokens","tlen","len","range","replaceRanges","ranges","offsetLength","descendingOrder","substr","matches","Number","parseInt","numberingToken","applyNumbering","applyNumbering$1","repeater","findRepeater","replaceNumbering","copy","unescapeString","_value","replaceNumberingRanges","range$$1","lastRange","getNumberingRanges","placeholder","caret","reUrl","reEmail","reProto","prepare","amount","implicit","index","insert","updated","inserted","insertContentIntoPlaceholder","setNodeContent","html_transform_es_findDeepestNode","insertContent","state","replaced","replacePlaceholder","_state","html_transform_es_defaultOptions","element","modifier","reElement","reModifier","blockCandidates1","className","blockCandidates2","getBlockName","lookup","prefix","depth","find","oldName","reSupporterNames","supportedAddons","bem","cl","startsWith","expandClassNames","createBlockLookup","originalClass","arrClassNames","Boolean","expandShortNotation","jsx","xsl","addons","addonOpt","use","html_transform_es","appliedAddons","replaceInString","variables","model","reVariable","tokens","exec","output","validMatches","location","createModel","v","variable_resolver_es","replaceInNode","DOLLAR","COLON","field_parser_es_ESCAPE","OPEN_BRACE","CLOSE_BRACE","createToken","consumeField","consumeIndex","Field","consumePlaceholder","FieldString","fields","field","order","sort","b","mark","cleanString","defaultFieldsRenderer","OutputNode","fieldsRenderer","_fieldsRenderer","open","beforeOpen","afterOpen","close","beforeClose","afterClose","beforeText","afterText","indent","newline","lines","splitByLines","nl","line","_wrap","indentText","defaultField","output_renderer_es","formatter","fieldState","run","nodes","outNode","toString","field_parser_es","largestIndex","getFieldsModel","TOKEN","TOKEN_OPEN","TOKEN_CLOSE","template","data","replacer","left","right","lastPos","markup_formatters_es_splitByLines","isFirstChild","isRoot","isPseudoSnippet","handlePseudoSnippet","fieldsModel","findLowestIndexField","parts","splitFieldsModel","renderFields","commentOptions","enabled","trigger","shouldFormatNode","profile","isInline","adjacentInline","isInlineElement","shouldFormatInline","reId","reClass","defaultAttrOptions","primary","secondary","isBoolean","defaultNodeOptions","omitName","indentFormat","level","getIndentLevel$1","NAME","SELF_CLOSE","selfClose","attribute","PRIMARY_ATTRS","SECONDARY_ATTRS","getAttributes","reNl","reNl$1","secondaryAttrs","none","curly","square","reNl$2","supportedSyntaxes","html","format","comment","getFormatOptions","skip","getIndentLevel","nodeName","hasInnerFormatting","setFormatting","attrName","attrValue","formatAttributes","toUpperCase","commentNode","haml","nodeOptions","updateFormatting","maxLength","max","pad","formatNodeValue","slim","attributeWrap","booleanAttr","isInline$1","updateFormatting$1","formatNodeValue$1","pug","updateFormatting$2","formatNodeValue$2","markup_formatters_es","syntax","supports","CSSValue","css_abbreviation_es_HASH","css_abbreviation_es_DOT","consumeColor","isHex","base","Color","alpha","raw","g","short","isShortHex","toShortHex","toHex","toFixed","toRGB","hex","num","css_abbreviation_es_pad","isAlphaNumericWord","isAlphaWord","PERCENT","css_abbreviation_es_DOT$1","DASH","consumeNumericValue","afterNegative","prevPos","eatNumber","NumericValue","unit","css_abbreviation_es_DOLLAR","DASH$1","AT","consumeKeyword","isVariableName","isKeyword","Keyword","css_abbreviation_es_opt","css_abbreviation_es_consumeQuoted","QuotedString","LBRACE","RBRACE","COMMA","consumeArgumentList","arg","argsList","consumeArgument","consumeKeywordOrFunction","kw","FunctionCall","css_abbreviation_es_EXCL","DOLLAR$1","PLUS","DASH$2","css_abbreviation_es_COLON","AT$1","consumeIdent","isIdentPrefix","isIdent","consumeValue","css_abbreviation_es","css_snippets_resolver_es_DASH","stringScore","abbrLength","stringLength","ch1","ch2","found","acronym","j","score","sum","reProperty","css_snippets_resolver_es_DASH$1","cssSnippets","snippets","snippetsSort","cur","addDependency","nest","CSSSnippet","dependencies","dep","defaultValue","splitValue","keywords","candidates","css_snippets_resolver_es_isKeyword","deps","globalKeywords","unitlessProperties","css_snippets_resolver_es_defaultOptions","intUnit","floatUnit","unitAliases","x","fuzzySearchMinScore","setNodeAsText","findBestMatch","items","matchedItem","maxScore","getScoringPart","isKeyword$1","tokenTypeOf","isNumericValue","resolveNumericValue","formatOptions","css_snippets_resolver_es","all","convertToCSSSnippets","resolveAsPropertyValue","getUnmatchedPart","resolveAsProperty","resolveAsSnippet","css_snippets_resolver_es_resolveNode","defaultFormatOptions","shortHex","between","css","formatOpt","stringifyValue","fieldsAmount","shift","delta","injectFields","endsWith","syntaxFormat","scss","less","sass","stylus","stylesheet_formatters_es_supports","getFormat","snippets_es","a:link","a:mail","a:tel","acr|acronym","basefont","br","frame","hr","bdo","bdo:r","bdo:l","col","link","link:css","link:print","link:favicon","link:touch","link:rss","link:atom","link:im|link:import","meta","meta:utf","meta:vp","meta:compat","meta:edge","meta:redirect","style","script:src","img","img:s|img:srcset","img:z|img:sizes","picture","src|source","src:sc|source:src","src:s|source:srcset","src:t|source:type","src:z|source:sizes","src:m|source:media","src:mt|source:media:type","src:mz|source:media:sizes","src:zt|source:sizes:type","iframe","embed","param","area","area:d","area:c","area:r","area:p","form","form:get","form:post","label","input","inp","input:h|input:hidden","input:t|input:text","input:search","input:email","input:url","input:p|input:password","input:datetime","input:date","input:datetime-local","input:month","input:week","input:time","input:tel","input:number","input:color","input:c|input:checkbox","input:r|input:radio","input:range","input:f|input:file","input:s|input:submit","input:i|input:image","input:b|input:button","input:reset","isindex","select:d|select:disabled","opt|option","textarea","marquee","menu:c|menu:context","menu:t|menu:toolbar","html:xml","keygen","command","btn:s|button:s|button:submit","btn:r|button:r|button:reset","btn:d|button:d|button:disabled","fst:d|fset:d|fieldset:d|fieldset:disabled","bq","fig","figc","pic","ifr","emb","obj","cap","colg","fst","btn","optg","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","mn","tem","fset","datag","datal","kg","det","cmd","ri:d|ri:dpr","ri:v|ri:viewport","ri:a|ri:art","ri:t|ri:type","!!!","doc","!|html:5","cc:ie","cc:noie","@f","@ff","@i|@import","@kf","@m|@media","ac","ai","anim","animdel","animdir","animdur","animfm","animic","animn","animps","animtf","ap","as","bd","bdb","bdbc","bdbi","bdbk","bdbli","bdblrs","bdbri","bdbrrs","bdbs","bdbw","bdc","bdci","bdcl","bdf","bdi","bdl","bdlc","bdlen","bdli","bdls","bdlw","bdr","bdrc","bdri","bdrs","bdrst","bdrw","bds","bdsp","bdt","bdtc","bdti","bdtli","bdtlrs","bdtri","bdtrrs","bdts","bdtw","bdw","bfv","bg","bga","bgbk","bgc","bgcp","bgi","bgo","bgp","bgpx","bgpy","bgr","bgsz","bxsh","bxsz","cm","cnt","coi","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","cor","cp","cps","ec","f","fef","fem","femp","fems","ff","fl","fs","fsm","fv","fw","fx","fxb","fxd","fxf","fxg","fxsh","fxw","fz","fza","h","jc","lg","lh","lis","lisi","lisp","list","lts","mah","mar","maw","mb","mih","mir","miw","ml","mr","mt","olc","olo","ols","olw","op","ord","ori","orp","ov","ovs","ovx","ovy","pb","pgba","pgbb","pgbi","pl","pr","pt","q","qen","qru","rsz","ta","tal","tbl","td","te","th","ti","tj","tov","trf","trfo","trfs","trs","trsde","trsdu","trsp","trstf","tsh","tt","tw","us","va","w","whs","whsc","wid","wm","wob","wos","wow","z","zom","tm|tmatch","tn|tname","api","imp","inc","wh|xsl:when","ot","if","par","pare","var","vare","wp","elem","co","val","for|each","tex","com","msg","fall","nam","pres","strip","proc","choose","langs","latin","common","words","ru","sp","lorem_es_defaultOptions","wordCount","skipCommon","lang","rand","floor","random","sample","iterations","min","sentence","word","capitalize","choice","insertCommas","hasComma","totalCommas","paragraph","dict","startWithCommon","totalWords","lorem_es","isRepeating","lorem_es_isRoot","Snippet","SnippetsStorage","_string","_regexp","_disabled","load","disabled","k","reset","clear","regexp","snippets_registry_es","_registry","store","fillResult","output_profile_es_defaultOptions","tagCase","attributeCase","attributeQuotes","formatSkip","formatForce","inlineBreak","compactBooleanAttributes","booleanAttributes","selfClosingStyle","strcase","output_profile_es","quoteChar","expand_es_parse","config","parse$1","reLorem","loremGenerator","defaultVariables","locale","charset","stylesheetSyntaxes","expand_es_defaultOptions","expand$2","getType","createOptions","stylesheet_formatters_es","expand$1","parse$2","createSnippetsRegistry","registrySnippets","snippetsRegistryFactory","isStylesheet","createProfile","webpackPolyfill","deprecate","paths","tinysort","undefined","__WEBPACK_AMD_DEFINE_RESULT__","window","loop","array","func","extend","fns","overwrite","undef","plugin","sortBy","plugins","nll","win","parsefloat","parseFloat","regexLastNr","regexLastNrNoDash","defaults","selector","useVal","place","returns","cases","natural","forceStrings","ignoreDashes","sortFunction","useFlex","emptyEnd","console","numCriteria","criteriumIndex","Element","elementPrototype","msMatchesSelector","nodeList","addCriterium","hasSelector","hasFilter","allOptions","criteria","hasAttr","hasData","sortReturnNumber","chunkify","tz","y","charAt","sortedIntoFragment","elmObjsSorted","elmObj","addGhost","ghost","parentNode","replaceGhost","elmObjGhost","ghostParent","getSortBy","elementObject","criterium","querySelector","isString","querySelectorAll","warn","elmObjsAll","elmObjsUnsorted","elmObjsSortedInitial","isSameParent","firstParent","isFragment","rootNode","isFlex","getComputedStyle","display","listPartial","posn","F","MAX_SAFE_INTEGER","regexLast","isNumeric","valueA","valueB","noA","noB","valuesA","valuesB","isNaN","aa","bb","naturalCompare","hasSortedAll","isPlaceStart","isPlaceEnd","isPlaceFirst","startElmObj","startParent","startElm","applyToDOM","QUnit","aList","sJoin","aSorted","_tinysort2","default","zenLi","eachElement","async","done","then","$","tsort","aNodeList","aLangSR","aLangDA","aLangFR","charOrder","aNodes","aLi","aTest","li","innerText","sSorted","log","foo","getLiFrom","listring","sHfJn","sSRvr","reverse","placeTest","mList","aArray","iNodes","unshift","_util","hidepassed","autostart"],"mappings":"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CAkrB,GAAA,mBACA+G,GAAA,sBACAC,IAAA,uBACAC,WAAA,uBACAC,IAAA,WACAC,IAAA,cACAC,IAAA,4BACAC,KAAA,eACApc,IAAA,oBACAqc,IAAA,mDACAC,KAAA,+BACAC,MAAA,4BACAC,KAAA,mCACAnlB,KAAA,yBACAolB,OAAA,oCACArnB,IAAA,uFACA+Z,MAAA,6CCnSA,MAAAuN,IAAeC,OA/FfC,QAAA,yEACAC,OAAA,kEACA,+DACA,+DACA,wDACA,4DACA,0DACA,8DACA,iEACA,2DACA,2DACA,4DACA,4DACA,wDACA,+DACA,2DACA,2DACA,8DACA,iEACA,gEACA,uDACA,4DACA,yDACA,4DACA,gEACA,4DACA,0DACA,6DACA,6DACA,sBAkEeC,IA9DfF,QAAA,yGACAC,OAAA,oEACA,4DACA,8DACA,oEACA,2DACA,8DACA,+DACA,iEACA,kEACA,+DACA,yDACA,+DACA,sDACA,4DACA,kEACA,oEACA,+DACA,gEACA,+DACA,+DACA,uEACA,0DACA,8DACA,6DACA,4DACA,0DAoCeE,IAhCfH,QAAA,uDACAC,OAAA,yDACA,kFACA,gEACA,qDACA,wEACA,4DACA,+DACA,uEACA,+DACA,8DACA,4DACA,+DACA,gEACA,qEACA,6DACA,6DACA,oEACA,+DACA,yEACA,gEACA,+DACA,8EACA,8DACA,8DACA,sDACA,6DACA,kEACA,kEACA,uBAKAG,IACAC,UAAA,GACAC,YAAA,EACAC,KAAA,SAsCA,SAAAC,GAAAt6B,EAAAsD,GACA,OAAA1C,KAAA25B,MAAA35B,KAAA45B,UAAAl3B,EAAAtD,MAQA,SAAAy6B,GAAAlzB,EAAAJ,GACA,MAAA8G,EAAA1G,EAAA7G,OACAg6B,EAAA95B,KAAA+5B,IAAA1sB,EAAA9G,GACA6B,EAAA,IAAA4C,IAEA,KAAA5C,EAAAxI,KAAAk6B,GACA1xB,EAAA1J,IAAAiI,EAAA+yB,GAAA,EAAArsB,KAGA,OAAAlO,MAAAC,KAAAgJ,GAOA,SAAA4xB,GAAAb,EAAApyB,GAKA,OAJAoyB,EAAAr5B,SACAq5B,GAMA,SAAAc,GACA,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","file":"test.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","import { expand } from '@emmetio/expand-abbreviation'\r\n\r\n/**\r\n * Turn a title into a slug\r\n * @param {String} s A string\r\n * @returns {string}\r\n */\r\nexport function toSlug(s) {\r\n  let str = s.toLowerCase()\r\n    ,replace = {\r\n      a: /[àáäâ]/g,\r\n      e: /[èéëê]/g,\r\n      i: /[ìíïî]/g,\r\n      o: /[òóöô]/g,\r\n      u: /[ùúüû]/g,\r\n      n: /[ñ]/g,\r\n      c: /[ç]/g,\r\n      '-': /[^a-z0-9]|-+/g,\r\n      '': /^-+|-+$/g\r\n    }\r\n  for (let replacement in replace) {\r\n    str = str.replace(replace[replacement],replacement)\r\n  }\r\n  return str\r\n}\r\n\r\n/**\r\n * Small utility method for quickly creating elements.\r\n * @param {String} [type='div'] The element type\r\n * @param {String|Array} classes An optional string or list of classes to be added\r\n * @param {HTMLElement} parent An optional parent to add the element to\r\n * @param {Object} attributes An optional click event handler\r\n * @param {String} text An optional click event handler\r\n * @param {Function} click An optional click event handler\r\n * @returns {HTMLElement} Returns the newly created element\r\n */\r\nexport function createElement(type,classes,parent,attributes,text,click) {\r\n  const mElement = document.createElement(type || 'div')\r\n  if (attributes) for (let attr in attributes) mElement.setAttribute(attr,attributes[attr])\r\n  if (classes) {\r\n    const oClassList = mElement.classList,aArguments = typeof(classes)==='string'?classes.split(' '):classes\r\n    oClassList.add.apply(oClassList,aArguments)\r\n  }\r\n  if (text) mElement.textContent = text\r\n  click && mElement.addEventListener('click',click)\r\n  parent && parent.appendChild(mElement)\r\n  return mElement\r\n}\r\n\r\n/**\r\n * Set the innerHTML of a cached div\r\n * Helper method for getFragment and stringToElement\r\n * @param {string} str\r\n * @returns {HTMLElement}\r\n */\r\nexport function wrapHTMLString(str) {\r\n  const div = document.createElement('div')\r\n  div.innerHTML = str\r\n  return div\r\n}\r\n\r\n/**\r\n * Get documentFragment from an HTML string\r\n * @param {string} str\r\n * @returns {DocumentFragment}\r\n */\r\nexport function getFragment(str) {\r\n  const fragment = document.createDocumentFragment()\r\n  Array.from(wrapHTMLString(str).childNodes).forEach(elm => fragment.appendChild(elm))\r\n  return fragment\r\n}\r\n\r\n/**\r\n * Turn an HTML string into an element\r\n * @param {string} str\r\n * @returns {HTMLElement}\r\n */\r\nexport function stringToElement(str) {\r\n  return wrapHTMLString(str.replace(/^\\s*|\\s*$/g, '')).childNodes[0]\r\n}\r\n\r\n/**\r\n * Formats a number to the appropriate filesize notation\r\n * @param {number} number The number to format\r\n * @param {number} round The number of decimals to round by\r\n * @returns {string} Filesize string result\r\n * @todo extend to generic formatter\r\n */\r\nexport function formatSize(number,round) {\r\n  let i, size = number\r\n  if (round===undefined) round = 0\r\n  const aSizes = ['B','kB','MB','GB','TB','PB','EB','ZB','YB']\r\n  for (i = 0; size>1024 && (aSizes.length>=(i + 2)); i++) size /= 1024\r\n  const iMult = Math.pow(10,round)\r\n  return (Math.round(size * iMult) / iMult) + aSizes[i]\r\n}\r\n\r\n/**\r\n * A simple function to use Emmet in a web environment\r\n * @property {Boolean} [firstChild=false] When set to true the result to the zen function is an HTMLElement when the length of the NodeList is one. Default is false.\r\n * @param {string} abbreviation The Emmet abbreviation to expand.\r\n * @param {Object} [content] An optional content object to replace strings from the result.\r\n * @returns {Array} The Emmet result in an Array.\r\n * @commnet const zen = s=>stringToElement(expand(s))\r\n */\r\nexport function zen(abbreviation,content) {\r\n  let i\r\n  let htmlString = expand(abbreviation)\r\n  if (content!==undefined) {\r\n    for (let key in content) {\r\n      const value = content[key]\r\n      if (value instanceof Array) {\r\n        for (i = value.length; i>=0; i--) {\r\n          htmlString = htmlString.replace(new RegExp(key + (i + 1),'g'),value[i])\r\n        }\r\n      } else {\r\n        htmlString = htmlString.replace(new RegExp(key,'g'),value)\r\n      }\r\n    }\r\n  }\r\n  return stringToElement(htmlString)\r\n}\r\n\r\n/**\r\n * Remove al element children\r\n * @param {HTMLElement} elm\r\n * @returns {HTMLElement}\r\n */\r\nexport function clearElement(elm){\r\n  while (elm.firstChild) elm.removeChild(elm.firstChild)\r\n  return elm\r\n}\r\n\r\n/**\r\n * Load a Javascript file\r\n * @param {string} src\r\n * @returns {Promise<any>}\r\n */\r\nexport function loadScript(src) {\r\n  return new Promise((resolve,reject)=>{\r\n    const script = document.createElement('script')\r\n    script.src = src\r\n    script.addEventListener('load',resolve)\r\n    script.addEventListener('error',reject)\r\n    document.body.appendChild(script)\r\n  })\r\n}","/**\n * Methods for consuming quoted values\n */\n\nconst SINGLE_QUOTE = 39; // '\nconst DOUBLE_QUOTE = 34; // \"\n\nconst defaultOptions = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @param  {Number}  options.escape A character code of quote-escape symbol\n * @param  {Boolean} options.throws Throw error if quotes string can’t be properly consumed\n * @return {Boolean} `true` if quoted string was consumed. The contents\n *                   of quoted string will be availabe as `stream.current()`\n */\nvar eatQuoted = function(stream, options) {\n\toptions = options ? Object.assign({}, defaultOptions, options) : defaultOptions;\n\tconst start = stream.pos;\n\tconst quote = stream.peek();\n\n\tif (stream.eat(isQuote)) {\n\t\twhile (!stream.eof()) {\n\t\t\tswitch (stream.next()) {\n\t\t\t\tcase quote:\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase options.escape:\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then stream wasn’t properly consumed.\n\t\t// Revert stream and decide what to do\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error('Unable to consume quoted string');\n\t\t}\n\t}\n\n\treturn false;\n};\n\nfunction isQuote(code) {\n\treturn code === SINGLE_QUOTE || code === DOUBLE_QUOTE;\n}\n\n/**\n * Check if given code is a number\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isNumber(code) {\n\treturn code > 47 && code < 58;\n}\n\n/**\n * Check if given character code is alpha code (letter through A to Z)\n * @param  {Number}  code\n * @param  {Number}  [from]\n * @param  {Number}  [to]\n * @return {Boolean}\n */\nfunction isAlpha(code, from, to) {\n\tfrom = from || 65; // A\n\tto   = to   || 90; // Z\n\tcode &= ~32; // quick hack to convert any char code to uppercase char code\n\n\treturn code >= from && code <= to;\n}\n\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumeric(code) {\n\treturn isNumber(code) || isAlpha(code);\n}\n\nfunction isWhiteSpace(code) {\n\treturn code === 32   /* space */\n\t\t|| code === 9    /* tab */\n\t\t|| code === 160; /* non-breaking space */\n}\n\n/**\n * Check if given character code is a space\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isSpace(code) {\n\treturn isWhiteSpace(code)\n\t\t|| code === 10  /* LF */\n\t\t|| code === 13; /* CR */\n}\n\nconst defaultOptions$1 = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param  {StreamReader} stream\n * @param  {Number} open      Character code of pair openinig\n * @param  {Number} close     Character code of pair closing\n * @param  {Object} [options]\n * @return {Boolean}       Returns `true` if chacarter pair was successfully\n *                         consumed, it’s content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n\toptions = options ? Object.assign({}, defaultOptions$1, options) : defaultOptions$1;\n\tconst start = stream.pos;\n\n\tif (stream.eat(open)) {\n\t\tlet stack = 1, ch;\n\n\t\twhile (!stream.eof()) {\n\t\t\tif (eatQuoted(stream, options)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tch = stream.next();\n\t\t\tif (ch === open) {\n\t\t\t\tstack++;\n\t\t\t} else if (ch === close) {\n\t\t\t\tstack--;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (ch === options.escape) {\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then paired character can’t be consumed\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport { eatQuoted, isQuote, isAlpha, isNumber, isAlphaNumeric, isSpace, isWhiteSpace, eatPair };\n","/**\n * Attribute descriptor of parsed abbreviation node\n * @param {String} name Attribute name\n * @param {String} value Attribute value\n * @param {Object} options Additional custom attribute options\n * @param {Boolean} options.boolean Attribute is boolean (e.g. name equals value)\n * @param {Boolean} options.implied Attribute is implied (e.g. must be outputted\n * only if contains non-null value)\n */\nclass Attribute {\n\tconstructor(name, value, options) {\n\t\tthis.name = name;\n\t\tthis.value = value != null ? value : null;\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * Create a copy of current attribute\n\t * @return {Attribute}\n\t */\n\tclone() {\n\t\treturn new Attribute(this.name, this.value, Object.assign({}, this.options));\n\t}\n\n\t/**\n\t * A string representation of current node\n\t */\n\tvalueOf() {\n\t\treturn `${this.name}=\"${this.value}\"`;\n\t}\n}\n\n/**\n * A parsed abbreviation AST node. Nodes build up an abbreviation AST tree\n */\nclass Node {\n\t/**\n\t * Creates a new node\n\t * @param {String} [name] Node name\n\t * @param {Array} [attributes] Array of attributes to add\n\t */\n\tconstructor(name, attributes) {\n\t\t// own properties\n\t\tthis.name = name || null;\n\t\tthis.value = null;\n\t\tthis.repeat = null;\n\t\tthis.selfClosing = false;\n\n\t\tthis.children = [];\n\n\t\t/** @type {Node} Pointer to parent node */\n\t\tthis.parent = null;\n\n\t\t/** @type {Node} Pointer to next sibling */\n\t\tthis.next = null;\n\n\t\t/** @type {Node} Pointer to previous sibling */\n\t\tthis.previous = null;\n\n\t\tthis._attributes = [];\n\n\t\tif (Array.isArray(attributes)) {\n\t\t\tattributes.forEach(attr => this.setAttribute(attr));\n\t\t}\n\t}\n\n\t/**\n\t * Array of current node attributes\n\t * @return {Attribute[]} Array of attributes\n\t */\n\tget attributes() {\n\t\treturn this._attributes;\n\t}\n\n\t/**\n\t * A shorthand to retreive node attributes as map\n\t * @return {Object}\n\t */\n\tget attributesMap() {\n\t\treturn this.attributes.reduce((out, attr) => {\n\t\t\tout[attr.name] = attr.options.boolean ? attr.name : attr.value;\n\t\t\treturn out;\n\t\t}, {});\n\t}\n\n\t/**\n\t * Check if current node is a grouping one, e.g. has no actual representation\n\t * and is used for grouping subsequent nodes only\n\t * @return {Boolean}\n\t */\n\tget isGroup() {\n\t\treturn !this.name && !this.value && !this._attributes.length;\n\t}\n\n\t/**\n\t * Check if given node is a text-only node, e.g. contains only value\n\t * @return {Boolean}\n\t */\n\tget isTextOnly() {\n\t\treturn !this.name && !!this.value && !this._attributes.length;\n\t}\n\n\t/**\n\t * Returns first child node\n\t * @return {Node}\n\t */\n\tget firstChild() {\n\t\treturn this.children[0];\n\t}\n\n\t/**\n\t * Returns last child of current node\n\t * @return {Node}\n\t */\n\tget lastChild() {\n\t\treturn this.children[this.children.length - 1];\n\t}\n\n\t/**\n\t * Return index of current node in its parent child list\n\t * @return {Number} Returns -1 if current node is a root one\n\t */\n\tget childIndex() {\n\t\treturn this.parent ? this.parent.children.indexOf(this) : -1;\n\t}\n\n\t/**\n\t * Returns next sibling of current node\n\t * @return {Node}\n\t */\n\tget nextSibling() {\n\t\treturn this.next;\n\t}\n\n\t/**\n\t * Returns previous sibling of current node\n\t * @return {Node}\n\t */\n\tget previousSibling() {\n\t\treturn this.previous;\n\t}\n\n\t/**\n\t * Returns array of unique class names in current node\n\t * @return {String[]}\n\t */\n\tget classList() {\n\t\tconst attr = this.getAttribute('class');\n\t\treturn attr && attr.value\n\t\t\t? attr.value.split(/\\s+/g).filter(uniqueClass)\n\t\t\t: [];\n\t}\n\n\t/**\n\t * Convenient alias to create a new node instance\n\t * @param {String} [name] Node name\n\t * @param {Object} [attributes] Attributes hash\n\t * @return {Node}\n\t */\n\tcreate(name, attributes) {\n\t\treturn new Node(name, attributes);\n\t}\n\n\t/**\n\t * Sets given attribute for current node\n\t * @param {String|Object|Attribute} name Attribute name or attribute object\n\t * @param {String} [value] Attribute value\n\t */\n\tsetAttribute(name, value) {\n\t\tconst attr = createAttribute(name, value);\n\t\tconst curAttr = this.getAttribute(name);\n\t\tif (curAttr) {\n\t\t\tthis.replaceAttribute(curAttr, attr);\n\t\t} else {\n\t\t\tthis._attributes.push(attr);\n\t\t}\n\t}\n\n\t/**\n\t * Check if attribute with given name exists in node\n\t * @param  {String} name\n\t * @return {Boolean}\n\t */\n\thasAttribute(name) {\n\t\treturn !!this.getAttribute(name);\n\t}\n\n\t/**\n\t * Returns attribute object by given name\n\t * @param  {String} name\n\t * @return {Attribute}\n\t */\n\tgetAttribute(name) {\n\t\tif (typeof name === 'object') {\n\t\t\tname = name.name;\n\t\t}\n\n\t\tfor (var i = 0; i < this._attributes.length; i++) {\n\t\t\tconst attr = this._attributes[i];\n\t\t\tif (attr.name === name) {\n\t\t\t\treturn attr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Replaces attribute with new instance\n\t * @param {String|Attribute} curAttribute Current attribute name or instance\n\t * to replace\n\t * @param {String|Object|Attribute} newName New attribute name or attribute object\n\t * @param {String} [newValue] New attribute value\n\t */\n\treplaceAttribute(curAttribute, newName, newValue) {\n\t\tif (typeof curAttribute === 'string') {\n\t\t\tcurAttribute = this.getAttribute(curAttribute);\n\t\t}\n\n\t\tconst ix = this._attributes.indexOf(curAttribute);\n\t\tif (ix !== -1) {\n\t\t\tthis._attributes.splice(ix, 1, createAttribute(newName, newValue));\n\t\t}\n\t}\n\n\t/**\n\t * Removes attribute with given name\n\t * @param  {String|Attribute} attr Atrtibute name or instance\n\t */\n\tremoveAttribute(attr) {\n\t\tif (typeof attr === 'string') {\n\t\t\tattr = this.getAttribute(attr);\n\t\t}\n\n\t\tconst ix = this._attributes.indexOf(attr);\n\t\tif (ix !== -1) {\n\t\t\tthis._attributes.splice(ix, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Removes all attributes from current node\n\t */\n\tclearAttributes() {\n\t\tthis._attributes.length = 0;\n\t}\n\n\t/**\n\t * Adds given class name to class attribute\n\t * @param {String} token Class name token\n\t */\n\taddClass(token) {\n\t\ttoken = normalize(token);\n\n\t\tif (!this.hasAttribute('class')) {\n\t\t\tthis.setAttribute('class', token);\n\t\t} else if (token && !this.hasClass(token)) {\n\t\t\tthis.setAttribute('class', this.classList.concat(token).join(' '));\n\t\t}\n\t}\n\n\t/**\n\t * Check if current node contains given class name\n\t * @param {String} token Class name token\n\t * @return {Boolean}\n\t */\n\thasClass(token) {\n\t\treturn this.classList.indexOf(normalize(token)) !== -1;\n\t}\n\n\t/**\n\t * Removes given class name from class attribute\n\t * @param {String} token Class name token\n\t */\n\tremoveClass(token) {\n\t\ttoken = normalize(token);\n\t\tif (this.hasClass(token)) {\n\t\t\tthis.setAttribute('class', this.classList.filter(name => name !== token).join(' '));\n\t\t}\n\t}\n\n\t/**\n\t * Appends child to current node\n\t * @param {Node} node\n\t */\n\tappendChild(node) {\n\t\tthis.insertAt(node, this.children.length);\n\t}\n\n\t/**\n\t * Inserts given `newNode` before `refNode` child node\n\t * @param {Node} newNode\n\t * @param {Node} refNode\n\t */\n\tinsertBefore(newNode, refNode) {\n\t\tthis.insertAt(newNode, this.children.indexOf(refNode));\n\t}\n\n\t/**\n\t * Insert given `node` at `pos` position of child list\n\t * @param {Node} node\n\t * @param {Number} pos\n\t */\n\tinsertAt(node, pos) {\n\t\tif (pos < 0 || pos > this.children.length) {\n\t\t\tthrow new Error('Unable to insert node: position is out of child list range');\n\t\t}\n\n\t\tconst prev = this.children[pos - 1];\n\t\tconst next = this.children[pos];\n\n\t\tnode.remove();\n\t\tnode.parent = this;\n\t\tthis.children.splice(pos, 0, node);\n\n\t\tif (prev) {\n\t\t\tnode.previous = prev;\n\t\t\tprev.next = node;\n\t\t}\n\n\t\tif (next) {\n\t\t\tnode.next = next;\n\t\t\tnext.previous = node;\n\t\t}\n\t}\n\n\t/**\n\t * Removes given child from current node\n\t * @param {Node} node\n\t */\n\tremoveChild(node) {\n\t\tconst ix = this.children.indexOf(node);\n\t\tif (ix !== -1) {\n\t\t\tthis.children.splice(ix, 1);\n\t\t\tif (node.previous) {\n\t\t\t\tnode.previous.next = node.next;\n\t\t\t}\n\n\t\t\tif (node.next) {\n\t\t\t\tnode.next.previous = node.previous;\n\t\t\t}\n\n\t\t\tnode.parent = node.next = node.previous = null;\n\t\t}\n\t}\n\n\t/**\n\t * Removes current node from its parent\n\t */\n\tremove() {\n\t\tif (this.parent) {\n\t\t\tthis.parent.removeChild(this);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a detached copy of current node\n\t * @param {Boolean} deep Clone node contents as well\n\t * @return {Node}\n\t */\n\tclone(deep) {\n\t\tconst clone = new Node(this.name);\n\t\tclone.value = this.value;\n\t\tclone.selfClosing = this.selfClosing;\n\t\tif (this.repeat) {\n\t\t\tclone.repeat = Object.assign({}, this.repeat);\n\t\t}\n\n\t\tthis._attributes.forEach(attr => clone.setAttribute(attr.clone()));\n\n\t\tif (deep) {\n\t\t\tthis.children.forEach(child => clone.appendChild(child.clone(true)));\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Walks on each descendant node and invokes given `fn` function on it.\n\t * The function receives two arguments: the node itself and its depth level\n\t * from current node. If function returns `false`, it stops walking\n\t * @param {Function} fn\n\t */\n\twalk(fn, _level) {\n\t\t_level = _level || 0;\n\t\tlet ctx = this.firstChild;\n\n\t\twhile (ctx) {\n\t\t\t// in case if context node will be detached during `fn` call\n\t\t\tconst next = ctx.next;\n\n\t\t\tif (fn(ctx, _level) === false || ctx.walk(fn, _level + 1) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tctx = next;\n\t\t}\n\t}\n\n\t/**\n\t * A helper method for transformation chaining: runs given `fn` function on\n\t * current node and returns the same node\n\t */\n\tuse(fn) {\n\t\tconst args = [this];\n\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\targs.push(arguments[i]);\n\t\t}\n\n\t\tfn.apply(null, args);\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst attrs = this.attributes.map(attr => {\n\t\t\tattr = this.getAttribute(attr.name);\n\t\t\tconst opt = attr.options;\n\t\t\tlet out = `${opt && opt.implied ? '!' : ''}${attr.name || ''}`;\n\t\t\tif (opt && opt.boolean) {\n\t\t\t\tout += '.';\n\t\t\t} else if (attr.value != null) {\n\t\t\t\tout += `=\"${attr.value}\"`;\n\t\t\t}\n\t\t\treturn out;\n\t\t});\n\n\t\tlet out = `${this.name || ''}`;\n\t\tif (attrs.length) {\n\t\t\tout += `[${attrs.join(' ')}]`;\n\t\t}\n\n\t\tif (this.value != null) {\n\t\t\tout += `{${this.value}}`;\n\t\t}\n\n\t\tif (this.selfClosing) {\n\t\t\tout += '/';\n\t\t}\n\n\t\tif (this.repeat) {\n\t\t\tout += `*${this.repeat.count ? this.repeat.count : ''}`;\n\t\t\tif (this.repeat.value != null) {\n\t\t\t\tout += `@${this.repeat.value}`;\n\t\t\t}\n\t\t}\n\n\t\treturn out;\n\t}\n}\n\n/**\n * Attribute factory\n * @param  {String|Attribute|Object} name  Attribute name or attribute descriptor\n * @param  {*} value Attribute value\n * @return {Attribute}\n */\nfunction createAttribute(name, value) {\n\tif (name instanceof Attribute) {\n\t\treturn name;\n\t}\n\n\tif (typeof name === 'string') {\n\t\treturn new Attribute(name, value);\n\t}\n\n\tif (name && typeof name === 'object') {\n\t\treturn new Attribute(name.name, name.value, name.options);\n\t}\n}\n\n/**\n * @param  {String} str\n * @return {String}\n */\nfunction normalize(str) {\n\treturn String(str).trim();\n}\n\nfunction uniqueClass(item, i, arr) {\n\treturn item && arr.indexOf(item) === i;\n}\n\nexport default Node;\n","/**\n * A streaming, character code-based string reader\n */\nclass StreamReader {\n\tconstructor(string, start, end) {\n\t\tif (end == null && typeof string === 'string') {\n\t\t\tend = string.length;\n\t\t}\n\n\t\tthis.string = string;\n\t\tthis.pos = this.start = start || 0;\n\t\tthis.end = end;\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\n\teof() {\n\t\treturn this.pos >= this.end;\n\t}\n\n\t/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * range. E.g. its `eof()` method will look at `end` property, not actual\n\t * stream end\n\t * @param  {Point} start\n\t * @param  {Point} end\n\t * @return {StreamReader}\n\t */\n\tlimit(start, end) {\n\t\treturn new this.constructor(this.string, start, end);\n\t}\n\n\t/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\n\tpeek() {\n\t\treturn this.string.charCodeAt(this.pos);\n\t}\n\n\t/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns <code>undefined</code> when no more characters are available.\n\t * @returns {Number}\n\t */\n\tnext() {\n\t\tif (this.pos < this.string.length) {\n\t\t\treturn this.string.charCodeAt(this.pos++);\n\t\t}\n\t}\n\n\t/**\n\t * `match` can be a character code or a function that takes a character code\n\t * and returns a boolean. If the next character in the stream 'matches'\n\t * the given argument, it is consumed and returned.\n\t * Otherwise, `false` is returned.\n\t * @param {Number|Function} match\n\t * @returns {Boolean}\n\t */\n\teat(match) {\n\t\tconst ch = this.peek();\n\t\tconst ok = typeof match === 'function' ? match(ch) : ch === match;\n\n\t\tif (ok) {\n\t\t\tthis.next();\n\t\t}\n\n\t\treturn ok;\n\t}\n\n\t/**\n\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t * fails. Returns <code>true</code> if any characters were eaten.\n\t * @param {Object} match\n\t * @returns {Boolean}\n\t */\n\teatWhile(match) {\n\t\tconst start = this.pos;\n\t\twhile (!this.eof() && this.eat(match)) {}\n\t\treturn this.pos !== start;\n\t}\n\n\t/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\n\tbackUp(n) {\n\t\tthis.pos -= (n || 1);\n\t}\n\n\t/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\n\tcurrent() {\n\t\treturn this.substring(this.start, this.pos);\n\t}\n\n\t/**\n\t * Returns substring for given range\n\t * @param  {Number} start\n\t * @param  {Number} [end]\n\t * @return {String}\n\t */\n\tsubstring(start, end) {\n\t\treturn this.string.slice(start, end);\n\t}\n\n\t/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\n\terror(message) {\n\t\tconst err = new Error(`${message} at char ${this.pos + 1}`);\n\t\terr.originalMessage = message;\n\t\terr.pos = this.pos;\n\t\terr.string = this.string;\n\t\treturn err;\n\t}\n}\n\nexport default StreamReader;\n","import { isNumber, eatQuoted, isWhiteSpace, isSpace, isQuote, isAlphaNumeric } from '@emmetio/stream-reader-utils';\nimport Node from '@emmetio/node';\nimport StreamReader from '@emmetio/stream-reader';\n\nconst ASTERISK = 42; // *\n\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n * @param  {StringReader} stream\n * @return {Object}\n */\nfunction consumeRepeat(stream) {\n\tif (stream.eat(ASTERISK)) {\n\t\tstream.start = stream.pos;\n\n\t\t// XXX think about extending repeat syntax with through numbering\n\t\treturn { count: stream.eatWhile(isNumber) ? +stream.current() : null };\n\t}\n}\n\nconst opt = { throws: true };\n\n/**\n * Consumes quoted literal from current stream position and returns it’s inner,\n * unquoted, value\n * @param  {StringReader} stream\n * @return {String} Returns `null` if unable to consume quoted value from current\n * position\n */\nfunction consumeQuoted(stream) {\n\tif (eatQuoted(stream, opt)) {\n\t\treturn stream.current().slice(1, -1);\n\t}\n}\n\nconst TEXT_START = 123; // {\nconst TEXT_END = 125; // }\nconst ESCAPE =  92; // \\ character\n\n/**\n * Consumes text node `{...}` from stream\n * @param  {StreamReader} stream\n * @return {String} Returns consumed text value (without surrounding braces) or\n * `null` if there’s no text at starting position\n */\nfunction consumeText(stream) {\n\t// NB using own implementation instead of `eatPair()` from @emmetio/stream-reader-utils\n\t// to disable quoted value consuming\n\tconst start = stream.pos;\n\n\tif (stream.eat(TEXT_START)) {\n\t\tlet stack = 1, ch;\n\t\tlet result = '';\n\t\tlet offset = stream.pos;\n\n\t\twhile (!stream.eof()) {\n\t\t\tch = stream.next();\n\t\t\tif (ch === TEXT_START) {\n\t\t\t\tstack++;\n\t\t\t} else if (ch === TEXT_END) {\n\t\t\t\tstack--;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn result + stream.substring(offset, stream.pos - 1);\n\t\t\t\t}\n\t\t\t} else if (ch === ESCAPE) {\n\t\t\t\tch = stream.next();\n\t\t\t\tif (ch === TEXT_START || ch === TEXT_END) {\n\t\t\t\t\tresult += stream.substring(offset, stream.pos - 2) + String.fromCharCode(ch);\n\t\t\t\t\toffset = stream.pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then paired character can’t be consumed\n\t\tstream.pos = start;\n\t\tthrow stream.error(`Unable to find closing ${String.fromCharCode(TEXT_END)} for text start`);\n\t}\n\n\treturn null;\n}\n\nconst EXCL       = 33; // .\nconst DOT        = 46; // .\nconst EQUALS     = 61; // =\nconst ATTR_OPEN  = 91; // [\nconst ATTR_CLOSE = 93; // ]\n\nconst reAttributeName = /^\\!?[\\w\\-:\\$@]+\\.?$/;\n\n/**\n * Consumes attributes defined in square braces from given stream.\n * Example:\n * [attr col=3 title=\"Quoted string\" selected. support={react}]\n * @param {StringReader} stream\n * @returns {Array} Array of consumed attributes\n */\nfunction consumeAttributes(stream) {\n\tif (!stream.eat(ATTR_OPEN)) {\n\t\treturn null;\n\t}\n\n\tconst result = [];\n\tlet token, attr;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\n\t\tif (stream.eat(ATTR_CLOSE)) {\n\t\t\treturn result; // End of attribute set\n\t\t} else if ((token = consumeQuoted(stream)) != null) {\n\t\t\t// Consumed quoted value: anonymous attribute\n\t\t\tresult.push({\n\t\t\t\tname: null,\n\t\t\t\tvalue: token\n\t\t\t});\n\t\t} else if (eatUnquoted(stream)) {\n\t\t\t// Consumed next word: could be either attribute name or unquoted default value\n\t\t\ttoken = stream.current();\n\t\t\tif (!reAttributeName.test(token)) {\n\t\t\t\t// anonymous attribute\n\t\t\t\tresult.push({ name: null, value: token });\n\t\t\t} else {\n\t\t\t\t// Looks like a regular attribute\n\t\t\t\tattr = parseAttributeName(token);\n\t\t\t\tresult.push(attr);\n\n\t\t\t\tif (stream.eat(EQUALS)) {\n\t\t\t\t\t// Explicitly defined value. Could be a word, a quoted string\n\t\t\t\t\t// or React-like expression\n\t\t\t\t\tif ((token = consumeQuoted(stream)) != null) {\n\t\t\t\t\t\tattr.value = token;\n\t\t\t\t\t} else if ((token = consumeText(stream)) != null) {\n\t\t\t\t\t\tattr.value = token;\n\t\t\t\t\t\tattr.options = {\n\t\t\t\t\t\t\tbefore: '{',\n\t\t\t\t\t\t\tafter: '}'\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (eatUnquoted(stream)) {\n\t\t\t\t\t\tattr.value = stream.current();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow stream.error('Expected attribute name');\n\t\t}\n\t}\n\n\tthrow stream.error('Expected closing \"]\" brace');\n}\n\nfunction parseAttributeName(name) {\n\tconst options = {};\n\n\t// If a first character in attribute name is `!` — it’s an implied\n\t// default attribute\n\tif (name.charCodeAt(0) === EXCL) {\n\t\tname = name.slice(1);\n\t\toptions.implied = true;\n\t}\n\n\t// Check for last character: if it’s a `.`, user wants boolean attribute\n\tif (name.charCodeAt(name.length - 1) === DOT) {\n\t\tname = name.slice(0, name.length - 1);\n\t\toptions.boolean = true;\n\t}\n\n\tconst attr = { name };\n\tif (Object.keys(options).length) {\n\t\tattr.options = options;\n\t}\n\n\treturn attr;\n}\n\n/**\n * Eats token that can be an unquoted value from given stream\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatUnquoted(stream) {\n\tconst start = stream.pos;\n\tif (stream.eatWhile(isUnquoted)) {\n\t\tstream.start = start;\n\t\treturn true;\n\t}\n}\n\nfunction isUnquoted(code) {\n\treturn !isSpace(code) && !isQuote(code)\n\t\t&& code !== ATTR_OPEN && code !== ATTR_CLOSE && code !== EQUALS;\n}\n\nconst HASH    = 35; // #\nconst DOT$1     = 46; // .\nconst SLASH   = 47; // /\n\n/**\n * Consumes a single element node from current abbreviation stream\n * @param  {StringReader} stream\n * @return {Node}\n */\nfunction consumeElement(stream) {\n\t// consume element name, if provided\n\tconst start = stream.pos;\n\tconst node = new Node(eatName(stream));\n\tlet next;\n\n\twhile (!stream.eof()) {\n\t\tif (stream.eat(DOT$1)) {\n\t\t\tnode.addClass(eatName(stream));\n\t\t} else if (stream.eat(HASH)) {\n\t\t\tnode.setAttribute('id', eatName(stream));\n\t\t} else if (stream.eat(SLASH)) {\n\t\t\t// A self-closing indicator must be at the end of non-grouping node\n\t\t\tif (node.isGroup) {\n\t\t\t\tstream.backUp(1);\n\t\t\t\tthrow stream.error('Unexpected self-closing indicator');\n\t\t\t}\n\t\t\tnode.selfClosing = true;\n\t\t\tif (next = consumeRepeat(stream)) {\n\t\t\t\tnode.repeat = next;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (next = consumeAttributes(stream)) {\n\t\t\tfor (let i = 0, il = next.length; i < il; i++) {\n\t\t\t\tnode.setAttribute(next[i]);\n\t\t\t}\n\t\t} else if ((next = consumeText(stream)) !== null) {\n\t\t\tnode.value = next;\n\t\t} else if (next = consumeRepeat(stream)) {\n\t\t\tnode.repeat = next;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === stream.pos) {\n\t\tthrow stream.error(`Unable to consume abbreviation node, unexpected ${stream.peek()}`);\n\t}\n\n\treturn node;\n}\n\nfunction eatName(stream) {\n\tstream.start = stream.pos;\n\tstream.eatWhile(isName);\n\treturn stream.current();\n}\n\nfunction isName(code) {\n\treturn isAlphaNumeric(code)\n\t\t|| code === 45 /* - */\n\t\t|| code === 58 /* : */\n\t\t|| code === 36 /* $ */\n\t\t|| code === 64 /* @ */\n\t\t|| code === 33 /* ! */\n\t\t|| code === 95 /* _ */\n\t\t|| code === 37 /* % */;\n}\n\nconst GROUP_START = 40; // (\nconst GROUP_END   = 41; // )\nconst OP_SIBLING  = 43; // +\nconst OP_CHILD    = 62; // >\nconst OP_CLIMB    = 94; // ^\n\n/**\n * Parses given string into a node tree\n * @param  {String} str Abbreviation to parse\n * @return {Node}\n */\nfunction parse(str) {\n\tconst stream = new StreamReader(str.trim());\n\tconst root = new Node();\n\tlet ctx = root, groupStack = [], ch;\n\n\twhile (!stream.eof()) {\n\t\tch = stream.peek();\n\n\t\tif (ch === GROUP_START) { // start of group\n\t\t\t// The grouping node should be detached to properly handle\n\t\t\t// out-of-bounds `^` operator. Node will be attached right on group end\n\t\t\tconst node = new Node();\n\t\t\tgroupStack.push([node, ctx, stream.pos]);\n\t\t\tctx = node;\n\t\t\tstream.next();\n\t\t\tcontinue;\n\t\t} else if (ch === GROUP_END) { // end of group\n\t\t\tconst lastGroup = groupStack.pop();\n\t\t\tif (!lastGroup) {\n\t\t\t\tthrow stream.error('Unexpected \")\" group end');\n\t\t\t}\n\n\t\t\tconst node = lastGroup[0];\n\t\t\tctx = lastGroup[1];\n\t\t\tstream.next();\n\n\t\t\t// a group can have a repeater\n\t\t\tif (node.repeat = consumeRepeat(stream)) {\n\t\t\t\tctx.appendChild(node);\n\t\t\t} else {\n\t\t\t\t// move all children of group into parent node\n\t\t\t\twhile (node.firstChild) {\n\t\t\t\t\tctx.appendChild(node.firstChild);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// for convenience, groups can be joined with optional `+` operator\n\t\t\tstream.eat(OP_SIBLING);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst node = consumeElement(stream);\n\t\tctx.appendChild(node);\n\n\t\tif (stream.eof()) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (stream.peek()) {\n\t\t\tcase OP_SIBLING:\n\t\t\t\tstream.next();\n\t\t\t\tcontinue;\n\n\t\t\tcase OP_CHILD:\n\t\t\t\tstream.next();\n\t\t\t\tctx = node;\n\t\t\t\tcontinue;\n\n\t\t\tcase OP_CLIMB:\n\t\t\t\t// it’s perfectly valid to have multiple `^` operators\n\t\t\t\twhile (stream.eat(OP_CLIMB)) {\n\t\t\t\t\tctx = ctx.parent || ctx;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (groupStack.length) {\n\t\tstream.pos = groupStack.pop()[2];\n\t\tthrow stream.error('Expected group close');\n\t}\n\n\treturn root;\n}\n\n/**\n * Parses given abbreviation and un-rolls it into a full tree: recursively\n * replaces repeated elements with actual nodes\n * @param  {String} abbr\n * @return {Node}\n */\nfunction index(abbr) {\n\tconst tree = parse(abbr);\n\ttree.walk(unroll);\n\treturn tree;\n}\n\nfunction unroll(node) {\n\tif (!node.repeat || !node.repeat.count) {\n\t\treturn;\n\t}\n\n\tconst parent = node.parent;\n\tlet ix = parent.children.indexOf(node);\n\n\tfor (let i = 0; i < node.repeat.count; i++) {\n\t\tconst clone = node.clone(true);\n\t\tclone.repeat.value = i + 1;\n\t\tclone.walk(unroll);\n\n\t\tif (clone.isGroup) {\n\t\t\twhile (clone.children.length > 0) {\n\t\t\t\tclone.firstChild.repeat = clone.repeat;\n\t\t\t\tparent.insertAt(clone.firstChild, ix++);\n\t\t\t}\n\t\t} else {\n\t\t\tparent.insertAt(clone, ix++);\n\t\t}\n\t}\n\n\tnode.parent.removeChild(node);\n}\n\nexport default index;\n//# sourceMappingURL=abbreviation.es.js.map\n","import parse from '@emmetio/abbreviation';\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * resolves it into a parsed abbreviation. Resolved node is then updated or\n * replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attribues and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n *\n * @param  {Node} tree                 Parsed Emmet abbreviation\n * @param  {SnippetsRegistry} registry Registry with all available snippets\n * @return {Node} Updated tree\n */\n\nvar index = function(tree, registry) {\n    tree.walk(node => resolveNode(node, registry));\n    return tree;\n};\n\nfunction resolveNode(node, registry) {\n    const stack = new Set();\n    const resolve = node => {\n        const snippet = registry.resolve(node.name);\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.has(snippet)) {\n            return;\n        }\n\n        // In case if matched snippet is a function, pass control into it\n        if (typeof snippet.value === 'function') {\n            return snippet.value(node, registry, resolve);\n        }\n\n        const tree = parse(snippet.value);\n\n        stack.add(snippet);\n        tree.walk(resolve);\n        stack.delete(snippet);\n\n        // move current node contents into new tree\n        const childTarget = findDeepestNode(tree);\n        merge(childTarget, node);\n\n        while (tree.firstChild) {\n            node.parent.insertBefore(tree.firstChild, node);\n        }\n\n        childTarget.parent.insertBefore(node, childTarget);\n        childTarget.remove();\n    };\n\n    resolve(node);\n}\n\n/**\n * Adds data from first node into second node and returns it\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction merge(from, to) {\n    to.name = from.name;\n\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n\n    if (from.value != null) {\n        to.value = from.value;\n    }\n\n    if (from.repeat) {\n        to.repeat = Object.assign({}, from.repeat);\n    }\n\n    return mergeAttributes(from, to);\n}\n\n/**\n * Transfer attributes from first element to second one and preserve first\n * element’s attributes order\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction mergeAttributes(from, to) {\n    mergeClassNames(from, to);\n\n    // It’s important to preserve attributes order: ones in `from` have higher\n    // pripority than in `to`. Collect attributes in map in order they should\n    // appear in `to`\n    const attrMap = new Map();\n\n    let attrs = from.attributes;\n    for (let i = 0; i < attrs.length; i++) {\n        attrMap.set(attrs[i].name, attrs[i].clone());\n    }\n\n    attrs = to.attributes.slice();\n    for (let i = 0, attr, a; i < attrs.length; i++) {\n        attr = attrs[i];\n        if (attrMap.has(attr.name)) {\n            a = attrMap.get(attr.name);\n            a.value = attr.value;\n\n            // If user explicitly wrote attribute in abbreviation, it’s no longer\n            // implied and should be outputted even if value is empty\n            if (a.options.implied) {\n                a.options.implied = false;\n            }\n        } else {\n            attrMap.set(attr.name, attr);\n        }\n\n        to.removeAttribute(attr);\n    }\n\n    const newAttrs = Array.from(attrMap.values());\n    for (let i = 0; i < newAttrs.length; i++) {\n        to.setAttribute(newAttrs[i]);\n    }\n\n    return to;\n}\n\n/**\n * Adds class names from first node to second one\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction mergeClassNames(from, to) {\n    const classNames = from.classList;\n    for (let i = 0; i < classNames.length; i++) {\n        to.addClass(classNames[i]);\n    }\n\n    return to;\n}\n\n/**\n * Finds node which is the deepest for in current node or node iteself.\n * @param  {Node} node\n * @return {Node}\n */\nfunction findDeepestNode(node) {\n\twhile (node.children.length) {\n\t\tnode = node.children[node.children.length - 1];\n\t}\n\n\treturn node;\n}\n\nexport default index;\n","const inlineElements = new Set('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(','));\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\n\n/**\n * Returns best child node name for given parent node name\n * @param  {String} parentName Name of parent node\n * @return {String}\n */\nfunction resolveImplicitName(parentName) {\n    parentName = (parentName || '').toLowerCase();\n    return elementMap[parentName]\n        || (inlineElements.has(parentName) ? 'span' : 'div');\n}\n\nexport default resolveImplicitName;\n","import resolveImplicitTag from '@emmetio/implicit-tag';\n\n/**\n * Adds missing tag names for given tree depending on node’s parent name\n */\nvar implicitTags = function(tree) {\n    tree.walk(node => {\n        // resolve only nameless nodes without content\n        if (node.name == null && node.attributes.length) {\n            node.name = resolveImplicitTag(node.parent.name);\n        }\n    });\n    return tree;\n};\n\n/**\n * Locates all occurances of given `token` which are not escaped (e.g. are not\n * preceded with `\\`) given in `str`\n * @param  {String} str\n * @return {Array}  Array of token ranges\n */\nfunction findUnescapedTokens(str, token) {\n    const result = new Set();\n    const tlen = token.length;\n\n    // 1. Find all occurances of tokens\n    let pos = 0;\n    while ((pos = str.indexOf(token, pos)) !== -1) {\n        result.add(pos);\n        pos += tlen;\n    }\n\n    if (result.size) {\n        // 2. Remove ones that escaped\n        let pos = 0;\n        const len = str.length;\n\n        while (pos < len) {\n            if (str[pos++] === '\\\\') {\n                result.delete(pos++);\n            }\n        }\n    }\n\n    return Array.from(result).map(ix => range(ix, tlen));\n}\n\n/**\n * Replaces `ranges`, generated by `range()` function, with given `value` in `str`\n * @param  {String} str    Where to replace ranges\n * @param  {Array} ranges Ranes, created by `range()` function\n * @param  {String|Function} value  Replacement value. If it’s a function, it\n * will take a range value as argument and should return a new string\n * @return {String}\n */\nfunction replaceRanges(str, ranges, value) {\n\t// should walk from the end of array to keep ranges valid after replacement\n\tfor (let i = ranges.length - 1; i >= 0; i--) {\n\t\tconst r = ranges[i];\n\n        let offset = 0;\n        let offsetLength = 0;\n        let descendingOrder = false;\n\n        if (str.substr(r[0] + r[1], 1) === '@'){\n            if (str.substr(r[0] + r[1] + 1, 1) === '-') {\n                descendingOrder = true;\n            } \n            const matches = str.substr(r[0] + r[1] + 1 + Number(descendingOrder)).match(/^(\\d+)/);\n            if (matches) {\n                offsetLength = matches[1].length + 1 + Number(descendingOrder);\n                offset = parseInt(matches[1]) - 1;\n            } else {\n                offsetLength = 2;\n            }\n        }\n\n\t\tstr = str.substring(0, r[0])\n\t\t\t+ (typeof value === 'function' ? value(str.substr(r[0], r[1]), offset, descendingOrder) : value)\n\t\t\t+ str.substring(r[0] + r[1] + offsetLength);\n\t}\n\n\treturn str;\n}\n\nfunction range(start, length) {\n    return [start, length];\n}\n\nconst numberingToken = '$';\n\n/**\n * Numbering of expanded abbreviation: finds all nodes with `$` in value\n * or attributes and replaces its occurances with repeater value\n */\nvar applyNumbering = function(tree) {\n    tree.walk(applyNumbering$1);\n    return tree;\n};\n\n/**\n * Applies numbering for given node: replaces occurances of numbering token\n * in node’s name, content and attributes\n * @param  {Node} node\n * @return {Node}\n */\nfunction applyNumbering$1(node) {\n    const repeater = findRepeater(node);\n\n    if (repeater && repeater.value != null) {\n        // NB replace numbering in nodes with explicit repeater only:\n        // it solves issues with abbreviations like `xsl:if[test=$foo]` where\n        // `$foo` is preferred output\n        const value = repeater.value;\n        const count = repeater.count;\n\n        node.name = replaceNumbering(node.name, value, count);\n        node.value = replaceNumbering(node.value, value, count);\n        node.attributes.forEach(attr => {\n            const copy = node.getAttribute(attr.name).clone();\n            copy.name = replaceNumbering(attr.name, value, count);\n            copy.value = replaceNumbering(attr.value, value, count);\n            node.replaceAttribute(attr.name, copy);\n        });\n    }\n\n    return node;\n}\n\n/**\n * Returns repeater object for given node\n * @param  {Node} node\n * @return {Object}\n */\nfunction findRepeater(node) {\n    while (node) {\n        if (node.repeat) {\n            return node.repeat;\n        }\n\n        node = node.parent;\n    }\n}\n\n/**\n * Replaces numbering in given string\n * @param  {String} str\n * @param  {Number} value\n * @return {String}\n */\nfunction replaceNumbering(str, value, count) {\n    // replace numbering in strings only: skip explicit wrappers that could\n    // contain unescaped numbering tokens\n    if (typeof str === 'string') {\n        const ranges = getNumberingRanges(str);\n        return replaceNumberingRanges(str, ranges, value, count);\n    }\n\n    return str;\n}\n\n/**\n * Returns numbering ranges, e.g. ranges of `$` occurances, in given string.\n * Multiple adjacent ranges are combined\n * @param  {String} str\n * @return {Array}\n */\nfunction getNumberingRanges(str) {\n    return findUnescapedTokens(str || '', numberingToken)\n    .reduce((out, range$$1) => {\n        // skip ranges that actually belongs to output placeholder or tabstops\n        if (!/[#{]/.test(str[range$$1[0] + 1] || '')) {\n            const lastRange = out[out.length - 1];\n            if (lastRange && lastRange[0] + lastRange[1] === range$$1[0]) {\n                lastRange[1] += range$$1[1];\n            } else {\n                out.push(range$$1);\n            }\n        }\n\n        return out;\n    }, []);\n}\n\n/**\n * @param  {String} str\n * @param  {Array} ranges\n * @param  {Number} value\n * @return {String}\n */\nfunction replaceNumberingRanges(str, ranges, value, count) {\n    const replaced = replaceRanges(str, ranges, (token, offset, descendingOrder) => {\n    let _value = descendingOrder ? String(offset + count - value + 1) : String(value + offset);\n        // pad values for multiple numbering tokens, e.g. 3 for $$$ becomes 003\n        while (_value.length < token.length) {\n            _value = '0' + _value;\n        }\n        return _value;\n    });\n\n    // unescape screened numbering tokens\n    return unescapeString(replaced);\n}\n\n/**\n * Unescapes characters, screened with `\\`, in given string\n * @param  {String} str\n * @return {String}\n */\nfunction unescapeString(str) {\n    let i = 0, result = '';\n    const len = str.length;\n\n    while (i < len) {\n        const ch = str[i++];\n        result += (ch === '\\\\') ? (str[i++] || '') : ch;\n    }\n\n    return result;\n}\n\n/** Placeholder for inserted content */\nconst placeholder = '$#';\n\n/** Placeholder for caret */\nconst caret = '|';\n\nconst reUrl = /^((?:https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/;\nconst reEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\nconst reProto = /^([a-z]+:)?\\/\\//i;\n\n/**\n * Inserts content into node with implicit repeat count: this node is then\n * duplicated for each content item and content itself is inserted either into\n * deepest child or instead of a special token.\n *\n * This method uses two distinct steps: `prepare()` and `insert()` since most\n * likely these steps will be used separately to properly insert content\n * with unescaped `$` numbering markers.\n *\n * @param {Node} tree Parsed abbreviation\n * @param {String[]} content Array of content items to insert\n * @return {Node}\n */\n/**\n * Finds nodes with implicit repeat and creates `amount` copies of it in tree\n * @param  {Node} tree\n * @param  {Number} amount\n * @return {Node}\n */\nfunction prepare(tree, amount) {\n    amount = amount || 1;\n    tree.walk(node => {\n        if (node.repeat && node.repeat.count === null) {\n            for (let i = 0; i < amount; i++) {\n                const clone = node.clone(true);\n                clone.repeat.implicit = true;\n                clone.repeat.count = amount;\n                clone.repeat.value = i + 1;\n                clone.repeat.index = i;\n                node.parent.insertBefore(clone, node);\n            }\n\n            node.remove();\n        }\n    });\n\n    return tree;\n}\n\n/**\n * Inserts content into implicitly repeated nodes, created by `prepare()` method\n * @param  {Node} tree\n * @param  {String[]} content\n * @return {Node}\n */\nfunction insert(tree, content) {\n    if (Array.isArray(content) && content.length) {\n        let updated = false;\n        tree.walk(node => {\n            if (node.repeat && node.repeat.implicit) {\n                updated = true;\n                insertContent(node, content[node.repeat.index]);\n            }\n        });\n\n        if (!updated) {\n            // no node with implicit repeat was found, insert content as\n            // deepest child\n            setNodeContent(findDeepestNode(tree), content.join('\\n'));\n        }\n    }\n\n    return tree;\n}\n\n/**\n * Inserts `content` into given `node`: either replaces output placeholders\n * or inserts it into deepest child node\n * @param  {Node} node\n * @param  {String} content\n * @return {Node}\n */\nfunction insertContent(node, content) {\n\tlet inserted = insertContentIntoPlaceholder(node, content);\n\tnode.walk(child => inserted |= insertContentIntoPlaceholder(child, content));\n\n\tif (!inserted) {\n\t\t// no placeholders were found in node, insert content into deepest child\n\t\tsetNodeContent(findDeepestNode(node), content);\n\t}\n\n\treturn node;\n}\n\n/**\n * Inserts given `content` into placeholders for given `node`. Placeholders\n * might be available in attribute values and node content\n * @param  {Node} node\n * @param  {String} content\n * @return {Boolean} Returns `true` if placeholders were found and replaced in node\n */\nfunction insertContentIntoPlaceholder(node, content) {\n\tconst state = {replaced: false};\n\n\tnode.value = replacePlaceholder(node.value, content, state);\n\tnode.attributes.forEach(attr => {\n\t\tif (attr.value) {\n\t\t\tnode.setAttribute(attr.name, replacePlaceholder(attr.value, content, state));\n\t\t}\n\t});\n\n\treturn state.replaced;\n}\n\n/**\n * Replaces all placeholder occurances in given `str` with `value`\n * @param  {String} str\n * @param  {String} value\n * @param  {Object} [_state] If provided, set `replaced` property of given\n * object to `true` if placeholder was found and replaced\n * @return {String}\n */\nfunction replacePlaceholder(str, value, _state) {\n\tif (typeof str === 'string') {\n\t\tconst ranges = findUnescapedTokens(str, placeholder);\n\t\tif (ranges.length) {\n\t\t\tif (_state) {\n\t\t\t\t_state.replaced = true;\n\t\t\t}\n\n\t\t\tstr = replaceRanges(str, ranges, value);\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * Finds node which is the deepest for in current node or node iteself.\n * @param  {Node} node\n * @return {Node}\n */\nfunction findDeepestNode(node) {\n\twhile (node.children.length) {\n\t\tnode = node.children[node.children.length - 1];\n\t}\n\n\treturn node;\n}\n\n/**\n * Updates content of given node\n * @param {Node} node\n * @param {String} content\n */\nfunction setNodeContent(node, content) {\n\t// find caret position and replace it with content, if possible\n\tif (node.value) {\n\t\tconst ranges = findUnescapedTokens(node.value, caret);\n\t\tif (ranges.length) {\n\t\t\tnode.value = replaceRanges(node.value, ranges, content);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (node.name.toLowerCase() === 'a' || node.hasAttribute('href')) {\n\t\t// special case: inserting content into `<a>` tag\n\t\tif (reUrl.test(content)) {\n\t\t\tnode.setAttribute('href', (reProto.test(content) ? '' : 'http://') + content);\n\t\t} else if (reEmail.test(content)) {\n\t\t\tnode.setAttribute('href', 'mailto:' + content);\n\t\t}\n\t}\n\n\tnode.value = content;\n}\n\nconst defaultOptions = {\n\telement: '__',\n\tmodifier: '_'\n};\n\nconst reElement  = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = className => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = className => /^[a-z]/i.test(className);\n\n/**\n * BEM transformer: updates class names written as `-element` and\n * `_modifier` into full class names as described in BEM specs. Also adds missing\n * class names: fir example, if node contains `.block_modifier` class, ensures\n * that element contains `.block` class as well\n */\nvar bem = function(tree, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\n\ttree.walk(node => expandClassNames(node, options));\n\n\tconst lookup = createBlockLookup(tree);\n\ttree.walk(node => expandShortNotation(node, lookup, options));\n\n\treturn tree;\n};\n\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n * @param  {Node} node\n * @param  {Object} options\n * @return {Set}\n */\nfunction expandClassNames(node, options) {\n\tconst classNames = node.classList.reduce((out, cl) => {\n\t\t// remove all modifiers and element prefixes from class name to get a base element name\n\t\tconst ix = cl.indexOf('_');\n\t\tif (ix > 0 && !cl.startsWith('-')) {\n\t\t\tout.add(cl.slice(0, ix));\n\t\t    out.add(cl.slice(ix));\n\t\t\treturn out;\n\t\t}\n\n\t\treturn out.add(cl);\n\t}, new Set());\n\n\tif (classNames.size) {\n\t\tnode.setAttribute('class', Array.from(classNames).join(' '));\n\t}\n}\n\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n * @param  {Node} node      Parsed Emmet abbreviation node\n * @param  {Map} lookup     BEM block name lookup\n * @param  {Object} options\n */\nfunction expandShortNotation(node, lookup, options) {\n\tconst classNames = node.classList.reduce((out, cl) => {\n\t\tlet prefix, m;\n\t\tconst originalClass = cl;\n\n\t\t// parse element definition (could be only one)\n\t\tif (m = cl.match(reElement)) {\n\t\t\tprefix = getBlockName(node, lookup, m[1]) + options.element + m[2];\n\t\t\tout.add(prefix);\n\t\t\tcl = cl.slice(m[0].length);\n\t\t}\n\n\t\t// parse modifiers definitions \n\t\tif (m = cl.match(reModifier)) {\n\t\t\tif (!prefix) {\n\t\t\t\tprefix = getBlockName(node, lookup, m[1]);\n\t\t\t\tout.add(prefix);\n\t\t\t}\n\n\t\t\tout.add(`${prefix}${options.modifier}${m[2]}`);\n\t\t\tcl = cl.slice(m[0].length);\n\t\t}\n\n\t\tif (cl === originalClass) {\n\t\t\t// class name wasn’t modified: it’s not a BEM-specific class,\n\t\t\t// add it as-is into output\n\t\t\tout.add(originalClass);\n\t\t}\n\n\t\treturn out;\n\t}, new Set());\n\n\tconst arrClassNames = Array.from(classNames).filter(Boolean);\n\tif (arrClassNames.length) {\n\t\tnode.setAttribute('class', arrClassNames.join(' '));\n\t}\n}\n\n/**\n * Creates block name lookup for each node in given tree, e.g. finds block\n * name explicitly for each node\n * @param  {Node} tree\n * @return {Map}\n */\nfunction createBlockLookup(tree) {\n\tconst lookup = new Map();\n\n\ttree.walk(node => {\n\t\tconst classNames = node.classList;\n\t\tif (classNames.length) {\n\t\t\t// guess best block name from class or use parent’s block name\n\t\t\tlookup.set(node,\n\t\t\t\tfind(classNames, blockCandidates1)\n\t\t\t\t|| find(classNames, blockCandidates2)\n\t\t\t\t|| lookup.get(node.parent)\n\t\t\t);\n\t\t}\n\t});\n\n\treturn lookup;\n}\n\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n * @param  {Node} node\n * @param  {Map} lookup\n * @param  {String} prefix\n * @return {String}\n */\nfunction getBlockName(node, lookup, prefix) {\n\tlet depth = prefix.length > 1 ? prefix.length : 0;\n\n\t// NB don’t walk up to root node, stay at first root child in case of\n\t// too deep prefix\n\twhile (node.parent && node.parent.parent && depth--) {\n\t\tnode = node.parent;\n\t}\n\n\treturn lookup.get(node) || '';\n}\n\nfunction find(arr, filter) {\n\tfor(let i = 0; i < arr.length; i++){\n\t\tif (reElement.test(arr[i]) || reModifier.test(arr[i])) {\n\t\t\tbreak;\n\t\t}\n\t\tif (filter(arr[i])) {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nvar jsx = function(tree) {\n\ttree.walk(node => {\n\t\treplace(node, 'class', 'className');\n\t\treplace(node, 'for', 'htmlFor');\n\t});\n\treturn tree;\n};\n\nfunction replace(node, oldName, newName) {\n\tlet attr = node.getAttribute(oldName);\n\tif (attr) {\n\t\tattr.name = newName;\n\t}\n}\n\nconst reSupporterNames = /^xsl:(variable|with\\-param)$/i;\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nvar xsl = function(tree) {\n\ttree.walk(node => {\n\t\tif (reSupporterNames.test(node.name || '') && (node.children.length || node.value)) {\n\t\t\tnode.removeAttribute('select');\n\t\t}\n\t});\n\treturn tree;\n};\n\nconst supportedAddons = { bem, jsx, xsl };\n\n/**\n * Runs additional transforms on given tree.\n * These transforms may introduce side-effects and unexpected result\n * so they are not applied by default, authors must specify which addons\n * in `addons` argument as `{addonName: addonOptions}`\n * @param {Node} tree Parsed Emmet abbreviation\n * @param {Object} addons Add-ons to apply and their options\n */\nvar addons = function(tree, addons) {\n    Object.keys(addons || {}).forEach(key => {\n        if (key in supportedAddons) {\n            const addonOpt = typeof addons[key] === 'object' ? addons[key] : null;\n            tree = tree.use(supportedAddons[key], addonOpt);\n        }\n    });\n\n    return tree;\n};\n\n/**\n * Applies basic HTML-specific transformations for given parsed abbreviation:\n * – resolve implied tag names\n * – insert repeated content\n * – resolve node numbering\n */\nvar index = function(tree, content, appliedAddons) {\n    if (typeof content === 'string') {\n        content = [content];\n    } else if (content && typeof content === 'object' && !Array.isArray(content)) {\n        appliedAddons = content;\n        content = null;\n    }\n\n    return tree\n    .use(implicitTags)\n    .use(prepare, Array.isArray(content) ? content.length : null)\n    .use(applyNumbering)\n    .use(insert, content)\n    .use(addons, appliedAddons);\n};\n\nexport default index;\n","/**\n * Replaces all unescaped ${variable} occurances in given parsed abbreviation\n * `tree` with values provided in `variables` hash. Precede `$` with `\\` to\n * escape it and skip replacement\n * @param {Node} tree Parsed abbreviation tree\n * @param {Object} variables Variables values\n * @return {Node}\n */\nfunction replaceVariables(tree, variables) {\n\tvariables = variables || {};\n    tree.walk(node => replaceInNode(node, variables));\n    return tree;\n}\n\nfunction replaceInNode(node, variables) {\n    // Replace variables in attributes.\n    const attrs = node.attributes;\n\n    for (let i = 0, il = attrs.length; i < il; i++) {\n        const attr = attrs[i];\n        if (typeof attr.value === 'string') {\n            node.setAttribute(attr.name, replaceInString(attr.value, variables));\n        }\n    }\n\n    if (node.value != null) {\n        node.value = replaceInString(node.value, variables);\n    }\n\n    return node;\n}\n\n/**\n * Replaces all unescaped `${variable}` occurances in given string with values\n * from `variables` object\n * @param  {String} string\n * @param  {Object} variables\n * @return {String}\n */\nfunction replaceInString(string, variables) {\n    const model = createModel(string);\n    let offset = 0;\n    let output = '';\n\n    for (let i = 0, il = model.variables.length; i < il; i++) {\n        const v = model.variables[i];\n        let value = v.name in variables ? variables[v.name] : v.name;\n        if (typeof value === 'function') {\n            value = value(model.string, v, offset + v.location);\n        }\n\n        output += model.string.slice(offset, v.location) + value;\n        offset = v.location + v.length;\n    }\n\n    return output + model.string.slice(offset);\n}\n\n/**\n * Creates variable model from given string. The model contains a `string` with\n * all escaped variable tokens written without escape symbol and `variables`\n * property with all unescaped variables and their ranges\n * @param  {String} string\n * @return {Object}\n */\nfunction createModel(string) {\n    const reVariable = /\\$\\{([a-z][\\w\\-]*)\\}/ig;\n    const escapeCharCode = 92; // `\\` symbol\n    const variables = [];\n\n    // We have to replace unescaped (e.g. not preceded with `\\`) tokens.\n    // Instead of writing a stream parser, we’ll cut some edges here:\n    // 1. Find all tokens\n    // 2. Walk string char-by-char and resolve only tokens that are not escaped\n    const tokens = new Map();\n    let m;\n    while (m = reVariable.exec(string)) {\n        tokens.set(m.index, m);\n    }\n\n    if (tokens.size) {\n        let start = 0, pos = 0, len = string.length;\n        let output = '';\n        while (pos < len) {\n            if (string.charCodeAt(pos) === escapeCharCode && tokens.has(pos + 1)) {\n                // Found escape symbol that escapes variable: we should\n                // omit this symbol in output string and skip variable\n                const token = tokens.get(pos + 1);\n                output += string.slice(start, pos) + token[0];\n                start = pos = token.index + token[0].length;\n                tokens.delete(pos + 1);\n                continue;\n            }\n\n            pos++;\n        }\n\n        string = output + string.slice(start);\n\n        // Not using `.map()` here to reduce memory allocations\n        const validMatches = Array.from(tokens.values());\n        for (let i = 0, il = validMatches.length; i < il; i++) {\n            const token = validMatches[i];\n            variables.push({\n                name: token[1],\n                location: token.index,\n                length: token[0].length\n            });\n        }\n    }\n\n    return {string, variables};\n}\n\nexport default replaceVariables;\n","import StreamReader from '@emmetio/stream-reader';\nimport { isNumber } from '@emmetio/stream-reader-utils';\n\nconst DOLLAR      = 36;  // $\nconst COLON       = 58;  // :\nconst ESCAPE      = 92;  // \\\nconst OPEN_BRACE  = 123; // {\nconst CLOSE_BRACE = 125; // }\n\n/**\n * Finds fields in given string and returns object with field-less string\n * and array of fields found\n * @param  {String} string\n * @return {Object}\n */\nfunction parse(string) {\n\tconst stream = new StreamReader(string);\n\tconst fields = [];\n\tlet cleanString = '', offset = 0, pos = 0;\n\tlet code, field;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\t\tpos = stream.pos;\n\n\t\tif (code === ESCAPE) {\n\t\t\tstream.next();\n\t\t\tstream.next();\n\t\t} else if (field = consumeField(stream, cleanString.length + pos - offset)) {\n\t\t\tfields.push(field);\n\t\t\tcleanString += stream.string.slice(offset, pos) + field.placeholder;\n\t\t\toffset = stream.pos;\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn new FieldString(cleanString + stream.string.slice(offset), fields);\n}\n\n/**\n * Marks given `string` with `fields`: wraps each field range with\n * `${index:placeholder}` (by default) or any other token produced by `token`\n * function, if provided\n * @param  {String} string String to mark\n * @param  {Array} fields Array of field descriptor. A field descriptor is a\n * `{index, location, length}` array. It is important that fields in array\n * must be ordered by their location in string: some fields my refer the same\n * location so they must appear in order that user expects.\n * @param  {Function} [token] Function that generates field token. This function\n * received two arguments: `index` and `placeholder` and should return string\n * @return {String}  String with marked fields\n */\nfunction mark(string, fields, token) {\n\ttoken = token || createToken;\n\n\t// order fields by their location and appearence\n\t// NB field ranges should not overlap! (not supported yet)\n\tconst ordered = fields\n\t.map((field, order) => ({order, field, end: field.location + field.length}))\n\t.sort((a, b) => (a.end - b.end) || (a.order - b.order));\n\n\t// mark ranges in string\n\tlet offset = 0;\n\tconst result = ordered.map(item => {\n\t\tconst placeholder = string.substr(item.field.location, item.field.length);\n\t\tconst prefix = string.slice(offset, item.field.location);\n\t\toffset = item.end;\n\t\treturn prefix + token(item.field.index, placeholder);\n\t});\n\n\treturn result.join('') + string.slice(offset);\n}\n\n/**\n * Creates field token for string\n * @param  {Number} index       Field index\n * @param  {String} placeholder Field placeholder, could be empty string\n * @return {String}\n */\nfunction createToken(index, placeholder) {\n\treturn placeholder ? `\\${${index}:${placeholder}}` : `\\${${index}}`;\n}\n\n/**\n * Consumes field from current stream position: it can be an `$index` or\n * or `${index}` or `${index:placeholder}`\n * @param  {StreamReader} stream\n * @param  {Number}       location Field location in *clean* string\n * @return {Field} Object with `index` and `placeholder` properties if\n * field was successfully consumed, `null` otherwise\n */\nfunction consumeField(stream, location) {\n\tconst start = stream.pos;\n\n\tif (stream.eat(DOLLAR)) {\n\t\t// Possible start of field\n\t\tlet index = consumeIndex(stream);\n\t\tlet placeholder = '';\n\n\t\t// consumed $index placeholder\n\t\tif (index != null) {\n\t\t\treturn new Field(index, placeholder, location);\n\t\t}\n\n\t\tif (stream.eat(OPEN_BRACE)) {\n\t\t\tindex = consumeIndex(stream);\n\t\t\tif (index != null) {\n\t\t\t\tif (stream.eat(COLON)) {\n\t\t\t\t\tplaceholder = consumePlaceholder(stream);\n\t\t\t\t}\n\n\t\t\t\tif (stream.eat(CLOSE_BRACE)) {\n\t\t\t\t\treturn new Field(index, placeholder, location);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we reached here then there’s no valid field here, revert\n\t// back to starting position\n\tstream.pos = start;\n}\n\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumePlaceholder(stream) {\n\tlet code;\n\tconst stack = [];\n\tstream.start = stream.pos;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\n\t\tif (code === OPEN_BRACE) {\n\t\t\tstack.push(stream.pos);\n\t\t} else if (code === CLOSE_BRACE) {\n\t\t\tif (!stack.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstack.pop();\n\t\t}\n\t\tstream.next();\n\t}\n\n\tif (stack.length) {\n\t\tthrow stream.error('Unable to find matching \"}\" for curly brace at ' + stack.pop());\n\t}\n\n\treturn stream.current();\n}\n\n/**\n * Consumes integer from current stream position\n * @param  {StreamReader} stream\n * @return {Number}\n */\nfunction consumeIndex(stream) {\n\tstream.start = stream.pos;\n\tif (stream.eatWhile(isNumber)) {\n\t\treturn Number(stream.current());\n\t}\n}\n\nclass Field {\n\tconstructor(index, placeholder, location) {\n\t\tthis.index = index;\n\t\tthis.placeholder = placeholder;\n\t\tthis.location = location;\n\t\tthis.length = this.placeholder.length;\n\t}\n}\n\nclass FieldString {\n\t/**\n\t * @param {String} string\n\t * @param {Field[]} fields\n\t */\n\tconstructor(string, fields) {\n\t\tthis.string = string;\n\t\tthis.fields = fields;\n\t}\n\n\tmark(token) {\n\t\treturn mark(this.string, this.fields, token);\n\t}\n\n\ttoString() {\n\t\treturn this.string;\n\t}\n}\n\nexport default parse;\nexport { mark, createToken };\n//# sourceMappingURL=field-parser.es.js.map\n","import parseFields from '@emmetio/field-parser';\n\nconst defaultFieldsRenderer = text => text;\n\n/**\n * Output node is an object containing generated output for given Emmet\n * abbreviation node. Output node can be passed to various processors that\n * may shape-up final node output. The final output is simply a concatenation\n * of `.open`, `.text` and `.close` properties and its `.before*` and `.after*`\n * satellites\n * @param {Node}     node           Parsed Emmet abbreviation node\n * @param {Function} fieldsRenderer A function for rendering fielded text (text with\n * tabstops) for current node. @see ./render.js for details\n */\nclass OutputNode {\n\tconstructor(node, fieldsRenderer, options) {\n\t\tif (typeof fieldsRenderer === 'object') {\n\t\t\toptions = fieldsRenderer;\n\t\t\tfieldsRenderer = null;\n\t\t}\n\n\t\tthis.node = node;\n\t\tthis._fieldsRenderer = fieldsRenderer || defaultFieldsRenderer;\n\n\t\tthis.open = null;\n\t\tthis.beforeOpen = '';\n\t\tthis.afterOpen = '';\n\n\t\tthis.close = null;\n\t\tthis.beforeClose = '';\n\t\tthis.afterClose = '';\n\n\t\tthis.text = null;\n\t\tthis.beforeText = '';\n\t\tthis.afterText = '';\n\n\t\tthis.indent = '';\n\t\tthis.newline = '';\n\n\t\tif (options) {\n            Object.assign(this, options);\n        }\n\t}\n\n\tclone() {\n\t\treturn new this.constructor(this.node, this);\n\t}\n\n\t/**\n\t * Properly indents given multiline text\n\t * @param {String} text\n\t */\n\tindentText(text) {\n\t\tconst lines = splitByLines(text);\n        if (lines.length === 1) {\n            // no newlines, nothing to indent\n            return text;\n        }\n\n        // No newline and no indent means no formatting at all:\n        // in this case we should replace newlines with spaces\n        const nl = (!this.newline && !this.indent) ? ' ' : this.newline;\n        return lines.map((line, i) => i ? this.indent + line : line).join(nl);\n\t}\n\n\t/**\n\t * Renders given text with fields\n\t * @param {String} text\n\t * @return {String}\n\t */\n\trenderFields(text) {\n\t\treturn this._fieldsRenderer(text);\n\t}\n\n\ttoString(children) {\n\t\tconst open = this._wrap(this.open, this.beforeOpen, this.afterOpen);\n\t\tconst close = this._wrap(this.close, this.beforeClose, this.afterClose);\n\t\tconst text = this._wrap(this.text, this.beforeText, this.afterText);\n\n\t\treturn open + text + (children != null ? children : '') + close;\n\t}\n\n\t_wrap(str, before, after) {\n\t\tbefore = before != null ? before : '';\n\t\tafter = after != null ? after : '';\n\n        // automatically trim whitespace for non-empty wraps\n        if (str != null) {\n            str = before ? str.replace(/^\\s+/, '') : str;\n            str = after ? str.replace(/\\s+$/, '') : str;\n            return before + this.indentText(str) + after;\n        }\n\n        return '';\n\t}\n}\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nfunction splitByLines(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Default output of field (tabstop)\n * @param  {Number} index       Field index\n * @param  {String} placeholder Field placeholder, can be null\n * @return {String}\n */\nconst defaultField = (index, placeholder) => (placeholder || '');\n\n/**\n * Renders given parsed abbreviation `tree` via `formatter` function.\n\n * @param {Node}     tree      Parsed Emmet abbreviation\n * @param {Function} [field]   Optional function to format field/tabstop (@see `defaultField`)\n * @param {Function} formatter Output formatter function. It takes an output node—\n * a special wrapper for parsed node that holds formatting and output properties—\n * and updates its output properties to shape-up node’s output.\n * Function arguments:\n * \t– `outNode`: OutputNode\n * \t– `renderFields`: a helper function that parses fields/tabstops from given\n * \t   text and replaces them with `field` function output.\n * \t   It also takes care about field indicies and ensures that the same indicies\n * \t   from different nodes won’t collide\n */\nfunction render(tree, field, formatter) {\n    if (typeof formatter === 'undefined') {\n        formatter = field;\n        field = null;\n    }\n\n    field = field || defaultField;\n\n    // Each node may contain fields like `${1:placeholder}`.\n\t// Since most modern editors will link all fields with the same\n\t// index, we have to ensure that different nodes has their own indicies.\n\t// We’ll use this `fieldState` object to globally increment field indices\n\t// during output\n\tconst fieldState = { index: 1 };\n\n    const fieldsRenderer = text => text == null\n        ? field(fieldState.index++)\n        : getFieldsModel(text, fieldState).mark(field);\n\n\treturn run(tree.children, formatter, fieldsRenderer);\n}\n\nfunction run(nodes, formatter, fieldsRenderer) {\n\treturn nodes.map(node => {\n\t\tconst outNode = formatter(new OutputNode(node, fieldsRenderer));\n\t\treturn outNode ? outNode.toString(run(node.children, formatter, fieldsRenderer)) : '';\n\t}).join('');\n}\n\n/**\n * Returns fields (tab-stops) model with properly updated indices that won’t\n * collide with fields in other nodes of foprmatted tree\n * @param  {String|Object} text Text to get fields model from or model itself\n * @param  {Object} fieldState Abbreviation tree-wide field state reference\n * @return {Object} Field model\n */\nfunction getFieldsModel(text, fieldState) {\n\tconst model = typeof text === 'object' ? text : parseFields(text);\n    let largestIndex = -1;\n\n    model.fields.forEach(field => {\n\t\tfield.index += fieldState.index;\n\t\tif (field.index > largestIndex) {\n\t\t\tlargestIndex = field.index;\n\t\t}\n\t});\n\n\tif (largestIndex !== -1) {\n\t\tfieldState.index = largestIndex + 1;\n\t}\n\n    return model;\n}\n\nexport default render;\n","import parseFields from '@emmetio/field-parser';\nimport render from '@emmetio/output-renderer';\n\nconst TOKEN       = /^(.*?)([A-Z_]+)(.*?)$/;\nconst TOKEN_OPEN  = 91; // [\nconst TOKEN_CLOSE = 93; // ]\n\n/**\n * A basic templating engine.\n * Takes every `[TOKEN]` from given string and replaces it with\n * `TOKEN` value from given `data` attribute. The token itself may contain\n * various characters between `[`, token name and `]`. Contents of `[...]` will\n * be outputted only if `TOKEN` value is not empty. Also, only `TOKEN` name will\n * be replaced with actual value, all other characters will remain as is.\n *\n * Example:\n * ```\n * template('[<NAME>]', {NAME: 'foo'}) -> \"<foo>\"\n * template('[<NAME>]', {}) -> \"\"\n * ```\n */\nfunction template(str, data) {\n\tif (str == null) {\n\t\treturn str;\n\t}\n\n\t// NB since token may contain inner `[` and `]`, we can’t just use regexp\n\t// for replacement, should manually parse string instead\n\tconst stack = [];\n\tconst replacer = (str, left, token, right) =>\n\t\tdata[token] != null ? left + data[token] + right : '';\n\n\tlet output = '';\n\tlet offset = 0, i = 0;\n\tlet code, lastPos;\n\n\twhile (i < str.length) {\n\t\tcode = str.charCodeAt(i);\n\t\tif (code === TOKEN_OPEN) {\n\t\t\tstack.push(i);\n\t\t} else if (code === TOKEN_CLOSE) {\n\t\t\tlastPos = stack.pop();\n\t\t\tif (!stack.length) {\n\t\t\t\toutput += str.slice(offset, lastPos) +\n\t\t\t\t\tstr.slice(lastPos + 1, i).replace(TOKEN, replacer);\n\t\t\t\toffset = i + 1;\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn output + str.slice(offset);\n}\n\n/**\n * Various utility methods used by formatters\n */\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nfunction splitByLines(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Check if given node is a first child in its parent\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isFirstChild(node) {\n\treturn node.parent.firstChild === node;\n}\n\n/**\n * Check if given node is a root node\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isRoot(node) {\n\treturn node && !node.parent;\n}\n\n/**\n * Check if given node is a pseudo-snippet: a text-only node with explicitly\n * defined children\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isPseudoSnippet(node) {\n\treturn node.isTextOnly && !!node.children.length;\n}\n\n/**\n * Handles pseudo-snippet node.\n * A pseudo-snippet is a text-only node with explicitly defined children.\n * For such case, we have to figure out if pseudo-snippet contains fields\n * (tab-stops) in node value and “split” it: make contents before field with\n * lowest index node’s “open” part and contents after lowest index — “close”\n * part. With this trick a final output will look like node’s children\n * are nested inside node value\n * @param  {OutputNode} outNode\n * @return {Boolean} Returns “true” if given node is a pseudo-snippets,\n * `false` otherwise\n */\nfunction handlePseudoSnippet(outNode) {\n\tconst node = outNode.node; // original abbreviaiton node\n\n\tif (isPseudoSnippet(node)) {\n\t\tconst fieldsModel = parseFields(node.value);\n\t\tconst field = findLowestIndexField(fieldsModel);\n\t\tif (field) {\n\t\t\tconst parts = splitFieldsModel(fieldsModel, field);\n\t\t\toutNode.open = outNode.renderFields(parts[0]);\n\t\t\toutNode.close = outNode.renderFields(parts[1]);\n\t\t} else {\n\t\t\toutNode.text = outNode.renderFields(fieldsModel);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Finds field with lowest index in given text\n * @param  {Object} model\n * @return {Object}\n */\nfunction findLowestIndexField(model) {\n\treturn model.fields.reduce((result, field) =>\n\t\t!result || field.index < result.index ? field : result\n\t\t, null);\n}\n\n/**\n * Splits given fields model in two parts by given field\n * @param  {Object} model\n * @param  {Object} field\n * @return {Array} Two-items array\n */\nfunction splitFieldsModel(model, field) {\n\tconst ix = model.fields.indexOf(field);\n\n\tconst left = new model.constructor(\n\t\tmodel.string.slice(0, field.location),\n\t\tmodel.fields.slice(0, ix)\n\t);\n\n\tconst right = new model.constructor(\n\t\tmodel.string.slice(field.location + field.length),\n\t\tmodel.fields.slice(ix + 1)\n\t);\n\n\treturn [left, right];\n}\n\nconst commentOptions = {\n\t// enable node commenting\n\tenabled: false,\n\n\t// attributes that should trigger node commenting on specific node,\n\t// if commenting is enabled\n\ttrigger: ['id', 'class'],\n\n\t// comment before opening tag\n\tbefore: '',\n\n\t// comment after closing tag\n\tafter: '\\n<!-- /[#ID][.CLASS] -->'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as HTML, formatted according to\n * `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction html(tree, profile, options) {\n\toptions = Object.assign({}, options);\n\tconst format = getFormatOptions(options);\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = setFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\tif (node.name) {\n\t\t\t\tconst name = profile.name(node.name);\n\t\t\t\tconst attrs = formatAttributes(outNode, profile);\n\n\t\t\t\toutNode.open = `<${name}${attrs}${node.selfClosing ? profile.selfClose() : ''}>`;\n\t\t\t\tif (!node.selfClosing) {\n\t\t\t\t\toutNode.close = `</${name}>`;\n\t\t\t\t}\n\n\t\t\t\tcommentNode(outNode, format.comment);\n\t\t\t}\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(node.value);\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction setFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n\tif (shouldFormatNode(node, profile)) {\n\t\toutNode.indent = profile.indent(getIndentLevel(node, profile));\n\t\toutNode.newline = '\\n';\n\t\tconst prefix = outNode.newline + outNode.indent;\n\n\t\t// do not format the very first node in output\n\t\tif (!isRoot(node.parent) || !isFirstChild(node)) {\n\t\t\toutNode.beforeOpen = prefix;\n\t\t\tif (node.isTextOnly) {\n\t\t\t\toutNode.beforeText = prefix;\n\t\t\t}\n\t\t}\n\n\t\tif (hasInnerFormatting(node, profile)) {\n\t\t\tif (!node.isTextOnly) {\n\t\t\t\toutNode.beforeText = prefix + profile.indent(1);\n\t\t\t}\n\t\t\toutNode.beforeClose = prefix;\n\t\t}\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Check if given node should be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatNode(node, profile) {\n\tif (!profile.get('format')) {\n\t\treturn false;\n\t}\n\n\tif (node.parent.isTextOnly\n\t\t&& node.parent.children.length === 1\n\t\t&& parseFields(node.parent.value).fields.length) {\n\t\t// Edge case: do not format the only child of text-only node,\n\t\t// but only if parent contains fields\n\t\treturn false;\n\t}\n\n\treturn isInline(node, profile) ? shouldFormatInline(node, profile) : true;\n}\n\n/**\n * Check if given inline node should be formatted as well, e.g. it contains\n * enough adjacent siblings that should force formatting\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatInline(node, profile) {\n\tif (!isInline(node, profile)) {\n\t\treturn false;\n\t}\n\n\tif (isPseudoSnippet(node)) {\n\t\treturn true;\n\t}\n\n\t// check if inline node is the next sibling of block-level node\n\tif (node.childIndex === 0) {\n\t\t// first node in parent: format if it’s followed by a block-level element\n\t\tlet next = node;\n\t\twhile (next = next.nextSibling) {\n\t\t\tif (!isInline(next, profile)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t} else if (!isInline(node.previousSibling, profile)) {\n\t\t// node is right after block-level element\n\t\treturn true;\n\t}\n\n\tif (profile.get('inlineBreak')) {\n\t\t// check for adjacent inline elements before and after current element\n\t\tlet adjacentInline = 1;\n\t\tlet before = node, after = node;\n\n\t\twhile (isInlineElement((before = before.previousSibling), profile)) {\n\t\t\tadjacentInline++;\n\t\t}\n\n\t\twhile (isInlineElement((after = after.nextSibling), profile)) {\n\t\t\tadjacentInline++;\n\t\t}\n\n\t\tif (adjacentInline >= profile.get('inlineBreak')) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Another edge case: inline node contains node that should receive foramtting\n\tfor (let i = 0, il = node.children.length; i < il; i++) {\n\t\tif (shouldFormatNode(node.children[i], profile)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Check if given node contains inner formatting, e.g. any of its children should\n * be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction hasInnerFormatting(node, profile) {\n\t// check if node if forced for inner formatting\n\tconst nodeName = (node.name || '').toLowerCase();\n\tif (profile.get('formatForce').indexOf(nodeName) !== -1) {\n\t\treturn true;\n\t}\n\n\t// check if any of children should receive formatting\n\t// NB don’t use `childrent.some()` to reduce memory allocations\n\tfor (let i = 0; i < node.children.length; i++) {\n\t\tif (shouldFormatNode(node.children[i], profile)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Outputs attributes of given abbreviation node as HTML attributes\n * @param  {OutputNode} outNode\n * @param  {Profile}    profile\n * @return {String}\n */\nfunction formatAttributes(outNode, profile) {\n\tconst node = outNode.node;\n\n\treturn node.attributes.map(attr => {\n\t\tif (attr.options.implied && attr.value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst attrName = profile.attribute(attr.name);\n\t\tlet attrValue = null;\n\n\t\t// handle boolean attributes\n\t\tif (attr.options.boolean || profile.get('booleanAttributes').indexOf(attrName.toLowerCase()) !== -1) {\n\t\t\tif (profile.get('compactBooleanAttributes') && attr.value == null) {\n\t\t\t\treturn ` ${attrName}`;\n\t\t\t} else if (attr.value == null) {\n\t\t\t\tattrValue = attrName;\n\t\t\t}\n\t\t}\n\n\t\tif (attrValue == null) {\n\t\t\tattrValue = outNode.renderFields(attr.value);\n\t\t}\n\n\t\treturn ` ${attrName}=${profile.quote(attrValue)}`;\n\t}).join('');\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline(node, profile) {\n\treturn (node && node.isTextOnly) || isInlineElement(node, profile);\n}\n\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInlineElement(node, profile) {\n\treturn node && profile.isInline(node);\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @param  {Profile} profile\n * @param  {Number} level\n * @return {Number}\n */\nfunction getIndentLevel(node, profile) {\n\t// Increase indent level IF NOT:\n\t// * parent is text-only node\n\t// * there’s a parent node with a name that is explicitly set to decrease level\n\tconst skip = profile.get('formatSkip') || [];\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tif (skip.indexOf( (ctx.name || '').toLowerCase() ) === -1) {\n\t\t\tlevel++;\n\t\t}\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\n/**\n * Comments given output node, if required\n * @param  {OutputNode} outNode\n * @param  {Object} options\n */\nfunction commentNode(outNode, options) {\n\tconst node = outNode.node;\n\n\tif (!options.enabled || !options.trigger || !node.name) {\n\t\treturn;\n\t}\n\n\tconst attrs = outNode.node.attributes.reduce((out, attr) => {\n\t\tif (attr.name && attr.value != null) {\n\t\t\tout[attr.name.toUpperCase().replace(/-/g, '_')] = attr.value;\n\t\t}\n\n\t\treturn out;\n\t}, {});\n\n\t// add comment only if attribute trigger is present\n\tfor (let i = 0, il = options.trigger.length; i < il; i++) {\n\t\tif (options.trigger[i].toUpperCase() in attrs) {\n\t\t\toutNode.open = template(options.before, attrs) + outNode.open;\n\t\t\tif (outNode.close) {\n\t\t\t\toutNode.close += template(options.after, attrs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction getFormatOptions(options) {\n\tconst format = Object.assign({}, options && options.format);\n\tformat.comment = Object.assign({}, commentOptions, format.comment);\n\treturn format;\n}\n\nconst reId = /^id$/i;\nconst reClass = /^class$/i;\nconst defaultAttrOptions = {\n\tprimary: attrs => attrs.join(''),\n\tsecondary: attrs => attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${attr.value}`).join(', ')\n};\n\nconst defaultNodeOptions = {\n\topen: null,\n\tclose: null,\n\tomitName: /^div$/i,\n\tattributes: defaultAttrOptions\n};\n\nfunction indentFormat(outNode, profile, options) {\n\toptions = Object.assign({}, defaultNodeOptions, options);\n\tconst node = outNode.node;\n\n\toutNode.indent = profile.indent(getIndentLevel$1(node, profile));\n\toutNode.newline = '\\n';\n\n\t// Do not format the very first node in output\n\tif (!isRoot(node.parent) || !isFirstChild(node)) {\n\t\toutNode.beforeOpen = outNode.newline + outNode.indent;\n\t}\n\n\tif (node.name) {\n\t\tconst data = Object.assign({\n\t\t\tNAME: profile.name(node.name),\n\t\t\tSELF_CLOSE: node.selfClosing ? options.selfClose : null\n\t\t}, getAttributes(outNode, profile, options.attributes));\n\n\t\t// omit tag name if node has primary attributes\n\t\tif (options.omitName && options.omitName.test(data.NAME) && data.PRIMARY_ATTRS) {\n\t\t\tdata.NAME = null;\n\t\t}\n\n\t\tif (options.open != null) {\n\t\t\toutNode.open = template(options.open, data);\n\t\t}\n\n\t\tif (options.close != null) {\n\t\t\toutNode.close = template(options.close, data);\n\t\t}\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats attributes of given node into a string.\n * @param  {OutputNode} node          Output node wrapper\n * @param  {Profile}    profile       Output profile\n * @param  {Object}     options       Additional formatting options\n * @return {String}\n */\nfunction getAttributes(outNode, profile, options) {\n\toptions = Object.assign({}, defaultAttrOptions, options);\n\tconst primary = [], secondary = [];\n\tconst node = outNode.node;\n\n\tnode.attributes.forEach(attr => {\n\t\tif (attr.options.implied && attr.value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst name = profile.attribute(attr.name);\n\t\tconst value = outNode.renderFields(attr.value);\n\n\t\tif (reId.test(name)) {\n\t\t\tvalue && primary.push(`#${value}`);\n\t\t} else if (reClass.test(name)) {\n\t\t\tvalue && primary.push(`.${value.replace(/\\s+/g, '.')}`);\n\t\t} else {\n\t\t\tconst isBoolean = attr.value == null\n\t\t\t\t&& (attr.options.boolean || profile.get('booleanAttributes').indexOf(name.toLowerCase()) !== -1);\n\n\t\t\tsecondary.push({ name, value, isBoolean });\n\t\t}\n\t});\n\n\treturn {\n\t\tPRIMARY_ATTRS: options.primary(primary) || null,\n\t\tSECONDARY_ATTRS: options.secondary(secondary) || null\n\t};\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @return {Number}\n */\nfunction getIndentLevel$1(node) {\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tlevel++;\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\nconst reNl = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as HAML, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction haml(tree, profile, options) {\n\toptions = options || {};\n\tconst nodeOptions = {\n\t\topen: '[%NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)][SELF_CLOSE]',\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean\n\t\t\t\t\t? `${attr.name}${profile.get('compactBooleanAttributes') ? '' : '=true'}`\n\t\t\t\t\t: `${attr.name}=${profile.quote(attr.value)}`\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue(node, profile));\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, HAML is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n\tif (!node.isTextOnly && node.value) {\n\t\t// node with text: put a space before single-line text\n\t\toutNode.beforeText = reNl.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n\t}\n\n\treturn outNode;\n}\n/**\n * Formats value of given node: for multiline text we should add a ` |` suffix\n * at the end of each line. Also ensure that text is perfectly aligned.\n * @param  {Node}    node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue(node, profile) {\n\tif (node.value != null && reNl.test(node.value)) {\n\t\tconst lines = splitByLines(node.value);\n\t\tconst indent = profile.indent(1);\n\t\tconst maxLength = lines.reduce((prev, line) => Math.max(prev, line.length), 0);\n\n\t\treturn lines.map((line, i) => `${i ? indent : ''}${pad(line, maxLength)} |`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nfunction pad(text, len) {\n\twhile (text.length < len) {\n\t\ttext += ' ';\n\t}\n\n\treturn text;\n}\n\nconst reNl$1 = /\\n|\\r/;\nconst secondaryAttrs = {\n\tnone:   '[ SECONDARY_ATTRS]',\n\tround:  '[(SECONDARY_ATTRS)]',\n\tcurly:  '[{SECONDARY_ATTRS}]',\n\tsquare: '[[SECONDARY_ATTRS]'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as Slim, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction slim(tree, profile, options) {\n\toptions = options || {};\n\tconst SECONDARY_ATTRS = options.attributeWrap\n\t\t&& secondaryAttrs[options.attributeWrap]\n\t\t|| secondaryAttrs.none;\n\n\tconst booleanAttr = SECONDARY_ATTRS === secondaryAttrs.none\n\t\t? attr => `${attr.name}=true`\n\t\t: attr => attr.name;\n\n\tconst nodeOptions = {\n\t\topen: `[NAME][PRIMARY_ATTRS]${SECONDARY_ATTRS}[SELF_CLOSE]`,\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean\n\t\t\t\t\t? booleanAttr(attr)\n\t\t\t\t\t: `${attr.name}=${profile.quote(attr.value)}`\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting$1(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue$1(node, profile));\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Slim is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting$1(outNode, profile) {\n\tconst node = outNode.node;\n\tconst parent = node.parent;\n\n\t// Edge case: a single inline-level child inside node without text:\n\t// allow it to be inlined\n\tif (profile.get('inlineBreak') === 0 && isInline$1(node, profile)\n\t\t&& !isRoot(parent) && parent.value == null && parent.children.length === 1) {\n\t\toutNode.beforeOpen = ': ';\n\t}\n\n\tif (!node.isTextOnly && node.value) {\n\t\t// node with text: put a space before single-line text\n\t\toutNode.beforeText = reNl$1.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue$1(node, profile) {\n\tif (node.value != null && reNl$1.test(node.value)) {\n\t\tconst indent = profile.indent(1);\n\t\treturn splitByLines(node.value).map((line, i) => `${indent}${i ? ' ' : '|'} ${line}`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline$1(node, profile) {\n\treturn node && (node.isTextOnly || profile.isInline(node));\n}\n\nconst reNl$2 = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as Pug, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction pug(tree, profile, options) {\n\toptions = options || {};\n\tconst nodeOptions = {\n\t\topen: '[NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)]',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${profile.quote(attr.value)}`).join(', ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting$2(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue$2(node, profile));\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Pug is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting$2(outNode, profile) {\n\tconst node = outNode.node;\n\n\tif (!node.isTextOnly && node.value) {\n\t\t// node with text: put a space before single-line text\n\t\toutNode.beforeText = reNl$2.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue$2(node, profile) {\n\tif (node.value != null && reNl$2.test(node.value)) {\n\t\tconst indent = profile.indent(1);\n\t\treturn splitByLines(node.value).map(line => `${indent}| ${line}`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nconst supportedSyntaxes = { html, haml, slim, pug };\n\n/**\n * Outputs given parsed abbreviation in specified syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `html` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nfunction index(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports(syntax)) {\n\t\t// fallback to HTML if given syntax is not supported\n\t\tsyntax = 'html';\n\t}\n\n\treturn supportedSyntaxes[syntax](tree, profile, options);\n}\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nfunction supports(syntax) {\n\treturn !!syntax && syntax in supportedSyntaxes;\n}\n\nexport default index;\nexport { supports, template };\n//# sourceMappingURL=markup-formatters.es.js.map\n","import { isNumber, isAlpha, eatQuoted, isWhiteSpace } from '@emmetio/stream-reader-utils';\nimport Node from '@emmetio/node';\nimport StreamReader from '@emmetio/stream-reader';\n\n/**\n * A wrapper for holding CSS value\n */\nclass CSSValue {\n\tconstructor() {\n\t\tthis.type = 'css-value';\n\t\tthis.value = [];\n\t}\n\n\tget size() {\n\t\treturn this.value.length;\n\t}\n\n\tadd(value) {\n\t\tthis.value.push(value);\n\t}\n\n\thas(value) {\n\t\treturn this.value.indexOf(value) !== -1;\n\t}\n\n\ttoString() {\n\t\treturn this.value.join(' ');\n\t}\n}\n\nconst HASH = 35; // #\nconst DOT  = 46; // .\n\n/**\n * Consumes a color token from given string\n * @param  {StreamReader} stream\n * @return {Color} Returns consumend color object, `undefined` otherwise\n */\nfunction consumeColor(stream) {\n\t// supported color variations:\n\t// #abc   → #aabbccc\n\t// #0     → #000000\n\t// #fff.5 → rgba(255, 255, 255, 0.5)\n\t// #t     → transparent\n\tif (stream.peek() === HASH) {\n\t\tstream.start = stream.pos;\n\t\tstream.next();\n\n\t\tstream.eat(116) /* t */ || stream.eatWhile(isHex);\n\t\tconst base = stream.current();\n\n\t\t// a hex color can be followed by `.num` alpha value\n\t\tstream.start = stream.pos;\n\t\tif (stream.eat(DOT) && !stream.eatWhile(isNumber)) {\n\t\t\tthrow stream.error('Unexpected character for alpha value of color');\n\t\t}\n\n\t\treturn new Color(base, stream.current());\n\t}\n}\n\nclass Color {\n\tconstructor(value, alpha) {\n\t\tthis.type = 'color';\n\t\tthis.raw = value;\n\t\tthis.alpha = Number(alpha != null && alpha !== '' ? alpha : 1);\n\t\tvalue = value.slice(1); // remove #\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tif (value === 't') {\n\t\t\tthis.alpha = 0;\n\t\t} else {\n\t\t\tswitch (value.length) {\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tr = g = b = value + value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tr = g = b = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tr = value[0] + value[0];\n\t\t\t\t\tg = value[1] + value[1];\n\t\t\t\t\tb = value[2] + value[2];\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tvalue += value;\n\t\t\t\t\tr = value.slice(0, 2);\n\t\t\t\t\tg = value.slice(2, 4);\n\t\t\t\t\tb = value.slice(4, 6);\n\t\t\t}\n\t\t}\n\n\t\tthis.r = parseInt(r, 16);\n\t\tthis.g = parseInt(g, 16);\n\t\tthis.b = parseInt(b, 16);\n\t}\n\n\t/**\n\t * Output current color as hex value\n\t * @param {Boolean} shor Produce short value (e.g. #fff instead of #ffffff), if possible\n\t * @return {String}\n\t */\n\ttoHex(short) {\n\t\tconst fn = (short && isShortHex(this.r) && isShortHex(this.g) && isShortHex(this.b))\n\t\t\t? toShortHex : toHex;\n\n\t\treturn '#' + fn(this.r)  + fn(this.g) + fn(this.b);\n\t}\n\n\t/**\n\t * Output current color as `rgba?(...)` CSS color\n\t * @return {String}\n\t */\n\ttoRGB() {\n\t\tconst values = [this.r, this.g, this.b];\n\t\tif (this.alpha !== 1) {\n\t\t\tvalues.push(this.alpha.toFixed(8).replace(/\\.?0+$/, ''));\n\t\t}\n\n\t\treturn `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n\t}\n\n\ttoString(short) {\n\t\tif (!this.r && !this.g && !this.b && !this.alpha) {\n\t\t\treturn 'transparent';\n\t\t}\n\t\treturn this.alpha === 1 ? this.toHex(short) : this.toRGB();\n\t}\n}\n\n/**\n * Check if given code is a hex value (/0-9a-f/)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isHex(code) {\n\treturn isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\n\nfunction isShortHex(hex) {\n\treturn !(hex % 17);\n}\n\nfunction toShortHex(num) {\n\treturn (num >> 4).toString(16);\n}\n\nfunction toHex(num) {\n\treturn pad(num.toString(16), 2);\n}\n\nfunction pad(value, len) {\n\twhile (value.length < len) {\n\t\tvalue = '0' + value;\n\t}\n\treturn value;\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumericWord(code) {\n\treturn isNumber(code) || isAlphaWord(code);\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaWord(code) {\n\treturn code === 95 /* _ */ || isAlpha(code);\n}\n\nconst PERCENT = 37; // %\nconst DOT$1     = 46; // .\nconst DASH    = 45; // -\n\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n * @param  {StreamReader} stream\n * @return {NumericValue}\n */\nfunction consumeNumericValue(stream) {\n\tstream.start = stream.pos;\n\tif (eatNumber(stream)) {\n\t\tconst num = stream.current();\n\t\tstream.start = stream.pos;\n\n\t\t// eat unit, which can be a % or alpha word\n\t\tstream.eat(PERCENT) || stream.eatWhile(isAlphaWord);\n\t\treturn new NumericValue(num, stream.current());\n\t}\n}\n\n/**\n * A numeric CSS value with optional unit\n */\nclass NumericValue {\n\tconstructor(value, unit) {\n\t\tthis.type = 'numeric';\n\t\tthis.value = Number(value);\n\t\tthis.unit = unit || '';\n\t}\n\n\ttoString() {\n\t\treturn `${this.value}${this.unit}`;\n\t}\n}\n\n/**\n * Eats number value from given stream\n * @param  {StreamReader} stream\n * @return {Boolean} Returns `true` if number was consumed\n */\nfunction eatNumber(stream) {\n\tconst start = stream.pos;\n\tconst negative = stream.eat(DASH);\n\tconst afterNegative = stream.pos;\n\n\tstream.eatWhile(isNumber);\n\t\n\tconst prevPos = stream.pos;\n\tif (stream.eat(DOT$1) && !stream.eatWhile(isNumber)) {\n\t\t// Number followed by a dot, but then no number\n\t\tstream.pos = prevPos;\n\t}\n\n\t// Edge case: consumed dash only: not a number, bail-out\n\tif (stream.pos === afterNegative) {\n\t\tstream.pos = start;\n\t}\n\n\treturn stream.pos !== start;\n}\n\nconst DOLLAR = 36; // $\nconst DASH$1   = 45; // -\nconst AT     = 64; // @\n\n/**\n * Consumes a keyword: either a variable (a word that starts with $ or @) or CSS\n * keyword or shorthand\n * @param  {StreamReader} stream\n * @param  {Boolean} [short] Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n * @return {String} Consumed variable\n */\nfunction consumeKeyword(stream, short) {\n\tstream.start = stream.pos;\n\n\tif (stream.eat(DOLLAR) || stream.eat(AT)) {\n\t\t// SCSS or LESS variable\n\t\tstream.eatWhile(isVariableName);\n\t} else if (short) {\n\t\tstream.eatWhile(isAlphaWord);\n\t} else {\n\t\tstream.eatWhile(isKeyword);\n\t}\n\n\treturn stream.start !== stream.pos ? new Keyword(stream.current()) : null;\n}\n\nclass Keyword {\n\tconstructor(value) {\n\t\tthis.type = 'keyword';\n\t\tthis.value = value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n}\n\nfunction isKeyword(code) {\n\treturn isAlphaNumericWord(code) || code === DASH$1;\n}\n\nfunction isVariableName(code) {\n\treturn code === 45 /* - */ || isAlphaNumericWord(code);\n}\n\nconst opt = { throws: true };\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumeQuoted(stream) {\n\tif (eatQuoted(stream, opt)) {\n\t\treturn new QuotedString(stream.current());\n\t}\n}\n\nclass QuotedString {\n\tconstructor(value) {\n\t\tthis.type = 'string';\n\t\tthis.value = value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n}\n\nconst LBRACE = 40; // (\nconst RBRACE = 41; // )\nconst COMMA  = 44; // ,\n\n/**\n * Consumes arguments from given string.\n * Arguments are comma-separated list of CSS values inside round braces, e.g.\n * `(1, a2, 'a3')`. Nested lists and quoted strings are supported\n * @param  {StreamReader} stream\n * @return {Array}        Array of arguments, `null` if arguments cannot be consumed\n */\nfunction consumeArgumentList(stream) {\n\tif (!stream.eat(LBRACE)) {\n\t\t// not an argument list\n\t\treturn null;\n\t}\n\n\tlet arg;\n\tconst argsList = [];\n\n\twhile (!stream.eof()) {\n\t\tif (arg = consumeArgument(stream)) {\n\t\t\targsList.push(arg);\n\t\t} else {\n\t\t\t// didn’t consumed argument, expect argument separator or end-of-arguments\n\t\t\tstream.eatWhile(isWhiteSpace);\n\n\t\t\tif (stream.eat(RBRACE)) {\n\t\t\t\t// end of arguments list\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!stream.eat(COMMA)) {\n\t\t\t\tthrow stream.error('Expected , or )');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn argsList;\n}\n\n/**\n * Consumes a single argument. An argument is a `CSSValue`, e.g. it could be\n * a space-separated string of value\n * @param  {StreamReader} stream\n * @return {CSSValue}\n */\nfunction consumeArgument(stream) {\n\tconst result = new CSSValue();\n\tlet value;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\t\tvalue = consumeNumericValue(stream) || consumeColor(stream)\n\t\t\t|| consumeQuoted(stream) || consumeKeywordOrFunction(stream);\n\n\t\tif (!value) {\n\t\t\tbreak;\n\t\t}\n\n\t\tresult.add(value);\n\t}\n\n\treturn result.size ? result : null;\n}\n\n/**\n * Consumes either function call like `foo()` or keyword like `foo`\n * @param  {StreamReader} stream\n * @return {Keyword|FunctionCall}\n */\nfunction consumeKeywordOrFunction(stream) {\n\tconst kw = consumeKeyword(stream);\n\tif (kw) {\n\t\tconst args = consumeArgumentList(stream);\n\t\treturn args ? new FunctionCall(kw.toString(), args) : kw;\n\t}\n}\n\nclass FunctionCall {\n\t/**\n\t * @param {String} name Function name\n\t * @param {Array}  args Function arguments\n\t */\n\tconstructor(name, args) {\n\t\tthis.type = 'function';\n\t\tthis.name = name;\n\t\tthis.args = args || [];\n\t}\n\n\ttoString() {\n\t\treturn `${this.name}(${this.args.join(', ')})`;\n\t}\n}\n\nconst EXCL   = 33; // !\nconst DOLLAR$1 = 36; // $\nconst PLUS   = 43; // +\nconst DASH$2   = 45; // -\nconst COLON  = 58; // :\nconst AT$1     = 64; // @\n\n/**\n * Parses given Emmet CSS abbreviation and returns it as parsed Node tree\n * @param {String} abbr\n * @return {Node}\n */\nfunction index(abbr) {\n\tconst root = new Node();\n\tconst stream = new StreamReader(abbr);\n\n\twhile (!stream.eof()) {\n\t\tlet node = new Node(consumeIdent(stream));\n\t\tnode.value = consumeValue(stream);\n\n\t\tconst args = consumeArgumentList(stream);\n\t\tif (args) {\n\t\t\t// technically, arguments in CSS are anonymous Emmet Node attributes,\n\t\t\t// but since Emmet can support only one anonymous, `null`-name\n\t\t\t// attribute (for good reasons), we’ll use argument index as name\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tnode.setAttribute(String(i), args[i]);\n\t\t\t}\n\t\t}\n\n\t\t// Consume `!important` modifier at the end of expression\n\t\tif (stream.eat(EXCL)) {\n\t\t\tnode.value.add('!');\n\t\t}\n\n\t\troot.appendChild(node);\n\n\t\t// CSS abbreviations cannot be nested, only listed\n\t\tif (!stream.eat(PLUS)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!stream.eof()) {\n\t\tthrow stream.error('Unexpected character');\n\t}\n\n\treturn root;\n}\n\n/**\n * Consumes CSS property identifier from given stream\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumeIdent(stream) {\n\tstream.start = stream.pos;\n\tstream.eatWhile(isIdentPrefix);\n\tstream.eatWhile(isIdent);\n\treturn stream.start !== stream.pos ? stream.current() : null;\n}\n\n/**\n * Consumes embedded value from Emmet CSS abbreviation stream\n * @param  {StreamReader} stream\n * @return {CSSValue}\n */\nfunction consumeValue(stream) {\n\tconst values = new CSSValue();\n\tlet value;\n\n\twhile (!stream.eof()) {\n\t\t// use colon as value separator\n\t\tstream.eat(COLON);\n\t\tif (value = consumeNumericValue(stream) || consumeColor(stream)) {\n\t\t\t// edge case: a dash after unit-less numeric value or color should\n\t\t\t// be treated as value separator, not negative sign\n\t\t\tif (!value.unit) {\n\t\t\t\tstream.eat(DASH$2);\n\t\t\t}\n\t\t} else {\n\t\t\tstream.eat(DASH$2);\n\t\t\tvalue = consumeKeyword(stream, true);\n\t\t}\n\n\t\tif (!value) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvalues.add(value);\n\t}\n\n\treturn values;\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isIdent(code) {\n\treturn isAlphaWord(code);\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isIdentPrefix(code) {\n\treturn code === AT$1 || code === DOLLAR$1 || code === EXCL;\n}\n\nexport default index;\n","const DASH = 45; // -\n\n/**\n * Calculates fuzzy match score of how close `abbr` matches given `string`.\n * @param  {String} abbr        Abbreviation to score\n * @param  {String} string      String to match\n * @param  {Number} [fuzziness] Fuzzy factor\n * @return {Number}             Match score\n */\nfunction stringScore(abbr, string) {\n\tabbr = abbr.toLowerCase();\n\tstring = string.toLowerCase();\n\n\tif (abbr === string) {\n\t\treturn 1;\n\t}\n\n\t// a string MUST start with the same character as abbreviation\n\tif (!string || abbr.charCodeAt(0) !== string.charCodeAt(0)) {\n\t\treturn 0;\n\t}\n\n\tconst abbrLength = abbr.length;\n\tconst stringLength = string.length;\n\tlet i = 1, j = 1, score = stringLength;\n\tlet ch1, ch2, found, acronym;\n\n\twhile (i < abbrLength) {\n\t\tch1 = abbr.charCodeAt(i);\n\t\tfound = false;\n\t\tacronym = false;\n\n\t\twhile (j < stringLength) {\n\t\t\tch2 = string.charCodeAt(j);\n\n\t\t\tif (ch1 === ch2) {\n\t\t\t\tfound = true;\n\t\t\t\tscore += (stringLength - j) * (acronym ? 2 : 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// add acronym bonus for exactly next match after unmatched `-`\n\t\t\tacronym = ch2 === DASH;\n\t\t\tj++;\n\t\t}\n\n\t\tif (!found) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn score && score * (i / abbrLength) / sum(stringLength);\n}\n\n/**\n * Calculates sum of first `n` natural numbers, e.g. 1+2+3+...n\n * @param  {Number} n\n * @return {Number}\n */\nfunction sum(n) {\n\treturn n * (n + 1) / 2;\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r]+))?$/;\nconst DASH$1 = 45; // -\n\n/**\n * Creates a special structure for resolving CSS properties from plain CSS\n * snippets.\n * Almost all CSS snippets are aliases for real CSS properties with available\n * value variants, optionally separated by `|`. Most values are keywords that\n * can be fuzzy-resolved as well. Some CSS properties are shorthands for other,\n * more specific properties, like `border` and `border-style`. For such cases\n * keywords from more specific properties should be available in shorthands too.\n * @param {Snippet[]} snippets\n * @return {CSSSnippet[]}\n */\nfunction cssSnippets(snippets) {\n\treturn nest( snippets.map(snippet => new CSSSnippet(snippet.key, snippet.value)) );\n}\n\nclass CSSSnippet {\n\tconstructor(key, value) {\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t\tthis.property = null;\n\n\t\t// detect if given snippet is a property\n\t\tconst m = value && value.match(reProperty);\n\t\tif (m) {\n\t\t\tthis.property = m[1];\n\t\t\tthis.value = m[2];\n\t\t}\n\n\t\tthis.dependencies = [];\n\t}\n\n\taddDependency(dep) {\n\t\tthis.dependencies.push(dep);\n\t}\n\n\tget defaultValue() {\n\t\treturn this.value != null ? splitValue(this.value)[0] : null;\n\t}\n\n\t/**\n\t * Returns list of unique keywords for current CSS snippet and its dependencies\n\t * @return {String[]}\n\t */\n\tkeywords() {\n\t\tconst stack = [];\n\t\tconst keywords = new Set();\n\t\tlet i = 0, item, candidates;\n\n\t\tif (this.property) {\n\t\t\t// scan valid CSS-properties only\n\t\t\tstack.push(this);\n\t\t}\n\n\t\twhile (i < stack.length) {\n\t\t\t// NB Keep items in stack instead of push/pop to avoid possible\n\t\t\t// circular references\n\t\t\titem = stack[i++];\n\n\t\t\tif (item.value) {\n\t\t\t\tcandidates = splitValue(item.value).filter(isKeyword);\n\n\t\t\t\t// extract possible keywords from snippet value\n\t\t\t\tfor (let j = 0; j < candidates.length; j++) {\n\t\t\t\t\tkeywords.add(candidates[j].trim());\n\t\t\t\t}\n\n\t\t\t\t// add dependencies into scan stack\n\t\t\t\tfor (let j = 0, deps = item.dependencies; j < deps.length; j++) {\n\t\t\t\t\tif (stack.indexOf(deps[j]) === -1) {\n\t\t\t\t\t\tstack.push(deps[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(keywords);\n\t}\n}\n\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * background-position-x -> background-position -> background\n * @param  {CSSSnippet[]} snippets\n * @return {CSSSnippet[]}\n */\nfunction nest(snippets) {\n\tsnippets = snippets.sort(snippetsSort);\n\tconst stack = [];\n\n\t// For sorted list of CSS properties, create dependency graph where each\n\t// shorthand property contains its more specific one, e.g.\n\t// background -> background-position -> background-position-x\n\tfor (let i = 0, cur, prev; i < snippets.length; i++) {\n\t\tcur = snippets[i];\n\n\t\tif (!cur.property) {\n\t\t\t// not a CSS property, skip it\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check if current property belongs to one from parent stack.\n\t\t// Since `snippets` array is sorted, items are perfectly aligned\n\t\t// from shorthands to more specific variants\n\t\twhile (stack.length) {\n\t\t\tprev = stack[stack.length - 1];\n\n\t\t\tif (cur.property.indexOf(prev.property) === 0\n\t\t\t\t&& cur.property.charCodeAt(prev.property.length) === DASH$1) {\n\t\t\t\tprev.addDependency(cur);\n\t\t\t\tstack.push(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstack.pop();\n\t\t}\n\n\t\tif (!stack.length) {\n\t\t\tstack.push(cur);\n\t\t}\n\t}\n\n\treturn snippets;\n}\n\n/**\n * A sorting function for array of snippets\n * @param  {CSSSnippet} a\n * @param  {CSSSnippet} b\n * @return {Number}\n */\nfunction snippetsSort(a, b) {\n\tif (a.key === b.key) {\n\t\treturn 0;\n\t}\n\n\treturn a.key < b.key ? -1 : 1;\n}\n\n/**\n * Check if given string is a keyword candidate\n * @param  {String}  str\n * @return {Boolean}\n */\nfunction isKeyword(str) {\n\treturn /^\\s*[\\w-]+/.test(str);\n}\n\nfunction splitValue(value) {\n\treturn String(value).split('|');\n}\n\nconst globalKeywords = ['auto', 'inherit', 'unset'];\nconst unitlessProperties = [\n\t'z-index', 'line-height', 'opacity', 'font-weight', 'zoom',\n\t'flex', 'flex-grow', 'flex-shrink'\n];\n\nconst defaultOptions = {\n\tintUnit: 'px',\n\tfloatUnit: 'em',\n\tunitAliases: {\n\t\te :'em',\n\t\tp: '%',\n\t\tx: 'ex',\n\t\tr: 'rem'\n\t},\n\tfuzzySearchMinScore: 0\n};\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * updates node with snippet data.\n *\n * This resolver uses fuzzy matching for searching matched snippets and their\n * keyword values.\n */\n\nfunction index(tree, registry, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\toptions.unitAliases = Object.assign({}, defaultOptions.unitAliases, options && options.unitAliases);\n\n\tconst snippets = convertToCSSSnippets(registry);\n\n\ttree.walk(node => resolveNode(node, snippets, options));\n\treturn tree;\n}\n\nfunction convertToCSSSnippets(registry) {\n\treturn cssSnippets(registry.all({type: 'string'}));\n}\n\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n * @param  {Node} node\n * @param  {CSSSnippet[]} snippets\n * @param  {Object} options\n * @return {Node}\n */\nfunction resolveNode(node, snippets, options) {\n\tif (options.property) {\n\t\t// Resolve as value of given CSS property\n\t\treturn resolveAsPropertyValue(node, snippets.find(snippet => snippet.property === options.property), options);\n\t}\n\n\tconst snippet = findBestMatch(node.name, snippets, 'key', options.fuzzySearchMinScore);\n\n\tif (!snippet) {\n\t\t// Edge case: `!important` snippet\n\t\treturn node.name === '!' ? setNodeAsText(node, '!important') : node;\n\t}\n\n\treturn snippet.property\n\t\t? resolveAsProperty(node, snippet, options)\n\t\t: resolveAsSnippet(node, snippet);\n}\n\n/**\n * Resolves given parsed abbreviation node as CSS property\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @param  {Object} formatOptions\n * @return {Node}\n */\nfunction resolveAsProperty(node, snippet, formatOptions) {\n\tconst abbr = node.name;\n\tnode.name = snippet.property;\n\n\tif (node.value && typeof node.value === 'object') {\n\t\t// resolve keyword shortcuts\n\t\tconst keywords = snippet.keywords();\n\n\t\tif (!node.value.size) {\n\t\t\t// no value defined, try to resolve unmatched part as a keyword alias\n\t\t\tlet kw = findBestMatch(getUnmatchedPart(abbr, snippet.key), keywords);\n\n\t\t\tif (!kw) {\n\t\t\t\t// no matching value, try to get default one\n\t\t\t\tkw = snippet.defaultValue;\n\t\t\t\tif (kw && kw.indexOf('${') === -1) {\n\t\t\t\t\t// Quick and dirty test for existing field. If not, wrap\n\t\t\t\t\t// default value in a field\n\t\t\t\t\tkw = `\\${1:${kw}}`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (kw) {\n\t\t\t\tnode.value.add(kw);\n\t\t\t}\n\t\t} else {\n\t\t\t// replace keyword aliases in current node value\n\t\t\tfor (let i = 0, token; i < node.value.value.length; i++) {\n\t\t\t\ttoken = node.value.value[i];\n\n\t\t\t\tif (token === '!') {\n\t\t\t\t\ttoken = `${!i ? '${1} ' : ''}!important`;\n\t\t\t\t} else if (isKeyword$1(token)) {\n\t\t\t\t\ttoken = findBestMatch(token.value, keywords)\n\t\t\t\t\t\t|| findBestMatch(token.value, globalKeywords)\n\t\t\t\t\t\t|| token;\n\t\t\t\t} else if (isNumericValue(token)) {\n\t\t\t\t\ttoken = resolveNumericValue(node.name, token, formatOptions);\n\t\t\t\t}\n\n\t\t\t\tnode.value.value[i] = token;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node;\n}\n\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @return {Node}\n */\nfunction resolveAsSnippet(node, snippet) {\n\treturn setNodeAsText(node, snippet.value);\n}\n\n/**\n * Resolves given parsed abbreviation node as property value of given `snippet`:\n * tries to find best matching keyword from CSS snippet\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @param {Object} options\n * @return {Node}\n */\nfunction resolveAsPropertyValue(node, snippet, options) {\n\t// Possible resolved result for CSS property:\n\t// * matched snippet keyword\n\t// * color (starts with #)\n\t// Everything else should result the same as input abbreviation\n\tlet keywords = globalKeywords.slice();\n\tif (snippet) {\n\t\tkeywords = keywords.concat(snippet.keywords());\n\t}\n\n\tconst values = [node.name].concat(node.value.value)\n\t\t.filter(Boolean)\n\t\t.map(value => {\n\t\t\tif (typeof value === 'string' || value.type === 'keyword') {\n\t\t\t\tvalue = String(value);\n\t\t\t\treturn findBestMatch(value, keywords, null, options.fuzzySearchMinScore) || value;\n\t\t\t}\n\n\t\t\treturn value;\n\t\t});\n\n\tnode.name = null;\n\tnode.value.value = values;\n\n\treturn node;\n}\n\n/**\n * Sets given parsed abbreviation node as a text snippet\n * @param {Node} node\n * @param {String} text\n * @return {Node}\n */\nfunction setNodeAsText(node, text) {\n\tnode.name = null;\n\tnode.value = text;\n\treturn node;\n}\n\n/**\n * Finds best matching item from `items` array\n * @param {String} abbr  Abbreviation to match\n * @param {Array}  items List of items for match\n * @param {String} [key] If `items` is a list of objects, use `key` as object\n * property to test against\n * @param {Number} fuzzySearchMinScore The minimum score the best matched item should have to be a valid match.\n * @return {*}\n */\nfunction findBestMatch(abbr, items, key, fuzzySearchMinScore) {\n\tif (!abbr) {\n\t\treturn null;\n\t}\n\n\tlet matchedItem = null;\n\tlet maxScore = 0;\n\tfuzzySearchMinScore = fuzzySearchMinScore || 0;\n\n\tfor (let i = 0, item; i < items.length; i++) {\n\t\titem = items[i];\n\t\tconst score = stringScore(abbr, getScoringPart(item, key));\n\n\t\tif (score === 1) {\n\t\t\t// direct hit, no need to look further\n\t\t\treturn item;\n\t\t}\n\n\t\tif (score && score >= maxScore) {\n\t\t\tmaxScore = score;\n\t\t\tmatchedItem = item;\n\t\t}\n\t}\n\n\treturn maxScore >= fuzzySearchMinScore ? matchedItem : null;\n}\n\nfunction getScoringPart(item, key) {\n\tconst value = item && typeof item === 'object' ? item[key] : item;\n\tconst m = (value || '').match(/^[\\w-@]+/);\n\treturn m ? m[0] : value;\n}\n\n/**\n * Returns a part of `abbr` that wasn’t directly matched agains `string`.\n * For example, if abbreviation `poas` is matched against `position`, the unmatched part will be `as`\n * since `a` wasn’t found in string stream\n * @param {String} abbr\n * @param {String} string\n * @return {String}\n */\nfunction getUnmatchedPart(abbr, string) {\n\tfor (let i = 0, lastPos = 0; i < abbr.length; i++) {\n\t\tlastPos = string.indexOf(abbr[i], lastPos);\n\t\tif (lastPos === -1) {\n\t\t\treturn abbr.slice(i);\n\t\t}\n\t\tlastPos++;\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if given CSS value token is a keyword\n * @param {*} token\n * @return {Boolean}\n */\nfunction isKeyword$1(token) {\n\treturn tokenTypeOf(token, 'keyword');\n}\n\n/**\n * Check if given CSS value token is a numeric value\n * @param  {*}  token\n * @return {Boolean}\n */\nfunction isNumericValue(token) {\n\treturn tokenTypeOf(token, 'numeric');\n}\n\nfunction tokenTypeOf(token, type) {\n\treturn token && typeof token === 'object' && token.type === type;\n}\n\n/**\n * Resolves numeric value for given CSS property\n * @param  {String} property    CSS property name\n * @param  {NumericValue} token CSS numeric value token\n * @param  {Object} formatOptions Formatting options for units\n * @return {NumericValue}\n */\nfunction resolveNumericValue(property, token, formatOptions) {\n\tif (token.unit) {\n\t\ttoken.unit = formatOptions.unitAliases[token.unit] || token.unit;\n\t} else if (token.value !== 0 && unitlessProperties.indexOf(property) === -1) {\n\t\t// use `px` for integers, `em` for floats\n\t\t// NB: num|0 is a quick alternative to Math.round(0)\n\t\ttoken.unit = token.value === (token.value|0) ? formatOptions.intUnit : formatOptions.floatUnit;\n\t}\n\n\treturn token;\n}\n\nexport default index;\nexport { convertToCSSSnippets, stringScore, cssSnippets };\n//# sourceMappingURL=css-snippets-resolver.es.js.map\n","import render from '@emmetio/output-renderer';\nimport parseFields from '@emmetio/field-parser';\n\nconst defaultFormatOptions = {\n\tshortHex: true,\n\tbetween: ': ',\n\tafter: ';'\n};\n\n/**\n * Renders given parsed Emmet CSS abbreviation as CSS-like\n * stylesheet, formatted according to `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction css(tree, profile, options) {\n\toptions = options || {};\n\tconst formatOpt = Object.assign({}, defaultFormatOptions, options && options.format);\n\n\treturn render(tree, options.field, outNode => {\n\t\tconst node = outNode.node;\n\t\tlet value = stringifyValue(node, formatOpt);\n\n\t\tif (node.attributes.length) {\n\t\t\tconst fieldValues = node.attributes.map(attr => stringifyValue(attr, formatOpt));\n\t\t\tvalue = injectFields(value, fieldValues);\n\t\t}\n\n\t\toutNode.open = node.name && profile.name(node.name);\n\t\toutNode.afterOpen = formatOpt.between;\n\t\toutNode.text = outNode.renderFields(value || null);\n\n\t\tif (outNode.open && (!outNode.text || !outNode.text.endsWith(';'))) {\n\t\t\toutNode.afterText = formatOpt.after;\n\t\t}\n\n\t\tif (profile.get('format')) {\n\t\t\toutNode.newline = '\\n';\n\t\t\tif (tree.lastChild !== node) {\n\t\t\t\toutNode.afterText += outNode.newline;\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Injects given field values at each field of given string\n * @param  {String}   string\n * @param  {String[]} attributes\n * @return {FieldString}\n */\nfunction injectFields(string, values) {\n\tconst fieldsModel = parseFields(string);\n\tconst fieldsAmount = fieldsModel.fields.length;\n\n\tif (fieldsAmount) {\n\t\tvalues = values.slice();\n\t\tif (values.length > fieldsAmount) {\n\t\t\t// More values that output fields: collapse rest values into\n\t\t\t// a single token\n\t\t\tvalues = values.slice(0, fieldsAmount - 1)\n\t\t\t\t.concat(values.slice(fieldsAmount - 1).join(', '));\n\t\t}\n\n\t\twhile (values.length) {\n\t\t\tconst value = values.shift();\n\t\t\tconst field = fieldsModel.fields.shift();\n\t\t\tconst delta = value.length - field.length;\n\n\t\t\tfieldsModel.string = fieldsModel.string.slice(0, field.location)\n\t\t\t\t+ value\n\t\t\t\t+ fieldsModel.string.slice(field.location + field.length);\n\n\t\t\t// Update location of the rest fields in string\n\t\t\tfor (let i = 0, il = fieldsModel.fields.length; i < il; i++) {\n\t\t\t\tfieldsModel.fields[i].location += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fieldsModel;\n}\n\nfunction stringifyValue(node, options) {\n\tif (node.value && typeof node.value === 'object' && node.value.type === 'css-value') {\n\t\treturn node.value.value\n\t\t.map(token => {\n\t\t\tif (token && typeof token === 'object') {\n\t\t\t\treturn token.type === 'color'\n\t\t\t\t\t? token.toString(options.shortHex)\n\t\t\t\t\t: token.toString();\n\t\t\t}\n\n\t\t\treturn String(token);\n\t\t})\n\t\t.join(' ');\n\t}\n\n\treturn node.value != null ? String(node.value) : '';\n}\n\nconst syntaxFormat = {\n\tcss: {\n\t\tbetween: ': ',\n\t\tafter: ';'\n\t},\n\tscss: 'css',\n\tless: 'css',\n\tsass: {\n\t\tbetween: ': ',\n\t\tafter: ''\n\t},\n\tstylus: {\n\t\tbetween: ' ',\n\t\tafter: ''\n\t}\n};\n\n/**\n * Outputs given parsed abbreviation in specified stylesheet syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `css` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nfunction index(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports(syntax)) {\n\t\t// fallback to CSS if given syntax is not supported\n\t\tsyntax = 'css';\n\t}\n\n\toptions = Object.assign({}, options, {\n\t\tformat: getFormat(syntax, options)\n\t});\n\n\t// CSS abbreviations doesn’t support nesting so simply\n\t// output root node children\n\treturn css(tree, profile, options);\n}\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nfunction supports(syntax) {\n\treturn !!syntax && syntax in syntaxFormat;\n}\n\n/**\n * Returns formatter object for given syntax\n * @param  {String} syntax\n * @param  {Object} [options]\n * @return {Object} Formatter object as defined in `syntaxFormat`\n */\nfunction getFormat(syntax, options) {\n\tlet format = syntaxFormat[syntax];\n\tif (typeof format === 'string') {\n\t\tformat = syntaxFormat[format];\n\t}\n\n\treturn Object.assign({}, format, options && options.format);\n}\n\nexport default index;\nexport { supports };\n//# sourceMappingURL=stylesheet-formatters.es.js.map\n","var html = {\n\t\"a\": \"a[href]\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"style\": \"style\",\n\t\"script\": \"script[!src]\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:button\": \"input[type=button value]\",\n    \"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+meta:edge+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar css = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${1});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:flex-start|flex-end|center|space-between|space-around|stretch\",\n\t\"ai\": \"align-items:flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:${1:time}\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:#${1:000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:#${1:000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:#${1:000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:#${1:000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:#${1:000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:#${1:000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} #${5:000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:#${1:000}\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters({$0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fz\": \"font-size\",\n\t\"fza\": \"font-size-adjust\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:flex-start|flex-end|center|space-between|space-around\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:#${1:000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xsl = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar index = { html, css, xsl };\n\nexport default index;\n","import resolveImplicitTag from '@emmetio/implicit-tag';\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst langs = { latin, ru, sp };\n\nconst defaultOptions = {\n\twordCount: 30,\n\tskipCommon: false,\n\tlang: 'latin'\n};\n\n/**\n * Replaces given parsed Emmet abbreviation node with nodes filled with\n * Lorem Ipsum stub text.\n * @param {Node} node\n * @return {Node}\n */\nvar index = function(node, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\tconst dict = langs[options.lang] || langs.latin;\n    const startWithCommon = !options.skipCommon && !isRepeating(node);\n\n\tif (!node.repeat && !isRoot(node.parent)) {\n\t\t// non-repeating element, insert text stub as a content of parent node\n\t\t// and remove current one\n\t\tnode.parent.value = paragraph(dict, options.wordCount, startWithCommon);\n\t\tnode.remove();\n\t} else {\n\t\t// Replace named node with generated content\n\t\tnode.value = paragraph(dict, options.wordCount, startWithCommon);\n\t\tnode.name = node.parent.name ? resolveImplicitTag(node.parent.name) : null;\n\t}\n\n\treturn node;\n};\n\nfunction isRoot(node) {\n\treturn !node.parent;\n}\n\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n * @param {Number} from\n * @param {Number} to\n * @returns {Number}\n */\nfunction rand(from, to) {\n\treturn Math.floor(Math.random() * (to - from) + from);\n}\n\n/**\n * @param {Array} arr\n * @param {Number} count\n * @returns {Array}\n */\nfunction sample(arr, count) {\n\tconst len = arr.length;\n\tconst iterations = Math.min(len, count);\n\tconst result = new Set();\n\n\twhile (result.size < iterations) {\n\t\tresult.add(arr[rand(0, len)]);\n\t}\n\n\treturn Array.from(result);\n}\n\nfunction choice(val) {\n\treturn val[rand(0, val.length - 1)];\n}\n\nfunction sentence(words, end) {\n\tif (words.length) {\n\t\twords = [capitalize(words[0])].concat(words.slice(1));\n\t}\n\n\treturn words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\n\nfunction capitalize(word) {\n\treturn word[0].toUpperCase() + word.slice(1);\n}\n\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside <code>words</code> array\n * @param {Array} words\n */\nfunction insertCommas(words) {\n\tif (words.length < 2) {\n\t\treturn words;\n\t}\n\n\twords = words.slice();\n\tconst len = words.length;\n\tconst hasComma = /,$/;\n\tlet totalCommas = 0;\n\n\tif (len > 3 && len <= 6) {\n\t\ttotalCommas = rand(0, 1);\n\t} else if (len > 6 && len <= 12) {\n\t\ttotalCommas = rand(0, 2);\n\t} else {\n\t\ttotalCommas = rand(1, 4);\n\t}\n\n\tfor (let i = 0, pos, word; i < totalCommas; i++) {\n\t\tpos = rand(0, len - 2);\n\t\tif (!hasComma.test(words[pos])) {\n\t\t\twords[pos] += ',';\n\t\t}\n\t}\n\n\treturn words;\n}\n\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param {Object} dict Words dictionary (see `lang/*.json`)\n * @param {Number} wordCount Words count in paragraph\n * @param {Boolean} startWithCommon Should paragraph start with common\n * \"lorem ipsum\" sentence.\n * @returns {String}\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n\tconst result = [];\n\tlet totalWords = 0;\n\tlet words;\n\n\tif (startWithCommon && dict.common) {\n\t\twords = dict.common.slice(0, wordCount);\n\t\ttotalWords += words.length;\n\t\tresult.push(sentence(insertCommas(words), '.'));\n\t}\n\n\twhile (totalWords < wordCount) {\n\t\twords = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n\t\ttotalWords += words.length;\n\t\tresult.push(sentence(insertCommas(words)));\n\t}\n\n\treturn result.join(' ');\n}\n\n/**\n * Check if given node is in repeating context, e.g. node itself or one of its\n * parent is repeated\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isRepeating(node) {\n    while (node.parent) {\n        if (node.repeat && node.repeat.value && node.repeat.value > 1) {\n            return true;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\nexport default index;\n","class Snippet {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n\nclass SnippetsStorage {\n    constructor(data) {\n        this._string = new Map();\n        this._regexp = new Map();\n        this._disabled = false;\n\n        this.load(data);\n    }\n\n    get disabled() {\n        return this._disabled;\n    }\n\n    /**\n     * Disables current store. A disabled store always returns `undefined`\n     * on `get()` method\n     */\n    disable() {\n        this._disabled = true;\n    }\n\n    /**\n     * Enables current store.\n     */\n    enable() {\n        this._disabled = false;\n    }\n\n    /**\n     * Registers a new snippet item\n     * @param {String|Regexp} key\n     * @param {String|Function} value\n     */\n    set(key, value) {\n        if (typeof key === 'string') {\n            key.split('|').forEach(k => this._string.set(k, new Snippet(k, value)));\n        } else if (key instanceof RegExp) {\n            this._regexp.set(key, new Snippet(key, value));\n        } else {\n            throw new Error('Unknow snippet key: ' + key);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns a snippet matching given key. It first tries to find snippet\n     * exact match in a string key map, then tries to match one with regexp key\n     * @param {String} key\n     * @return {Snippet}\n     */\n    get(key) {\n        if (this.disabled) {\n            return undefined;\n        }\n\n        if (this._string.has(key)) {\n            return this._string.get(key);\n        }\n\n        const keys = Array.from(this._regexp.keys());\n        for (let i = 0, il = keys.length; i < il; i++) {\n            if (keys[i].test(key)) {\n                return this._regexp.get(keys[i]);\n            }\n        }\n    }\n\n    /**\n     * Batch load of snippets data\n     * @param {Object|Map} data\n     */\n    load(data) {\n        this.reset();\n        if (data instanceof Map) {\n            data.forEach((value, key) => this.set(key, value));\n        } else if (data && typeof data === 'object') {\n            Object.keys(data).forEach(key => this.set(key, data[key]));\n        }\n    }\n\n    /**\n     * Clears all stored snippets\n     */\n    reset() {\n        this._string.clear();\n        this._regexp.clear();\n    }\n\n    /**\n     * Returns all available snippets from given store\n     */\n    values() {\n        if (this.disabled) {\n            return [];\n        }\n        \n        const string = Array.from(this._string.values());\n        const regexp = Array.from(this._regexp.values());\n        return string.concat(regexp);\n    }\n}\n\n/**\n * A snippets registry. Contains snippets, separated by store and sorted by\n * priority: a store with higher priority takes precedence when resolving snippet\n * for given key\n */\nclass SnippetsRegistry {\n    /**\n     * Creates snippets registry, filled with given `data`\n     * @param {Object|Array} data Registry snippets. If array is given, adds items\n     * from array in order of precedence, registers global snippets otherwise\n     */\n    constructor(data) {\n        this._registry = [];\n\n        if (Array.isArray(data)) {\n            data.forEach((snippets, level) => this.add(level, snippets));\n        } else if (typeof data === 'object') {\n            this.add(data);\n        }\n    }\n\n    /**\n     * Return store for given level\n     * @param {Number} level\n     * @return {SnippetsStorage}\n     */\n    get(level) {\n        for (let i = 0; i < this._registry.length; i++) {\n            const item = this._registry[i];\n            if (item.level === level) {\n                return item.store;\n            }\n        }\n    }\n\n    /**\n     * Adds new store for given level\n     * @param {Number} [level] Store level (priority). Store with higher level\n     * takes precedence when resolving snippets\n     * @param {Object} [snippets] A snippets data for new store\n     * @return {SnipetsStorage}\n     */\n    add(level, snippets) {\n        if (level != null && typeof level === 'object') {\n            snippets = level;\n            level = 0;\n        }\n\n        const store = new SnippetsStorage(snippets);\n\n        // remove previous store from same level\n        this.remove(level);\n\n        this._registry.push({level, store});\n        this._registry.sort((a, b) => b.level - a.level);\n\n        return store;\n    }\n\n    /**\n     * Remove registry with given level or store\n     * @param {Number|SnippetsStorage} data Either level or snippets store\n     */\n    remove(data) {\n        this._registry = this._registry\n        .filter(item => item.level !== data && item.store !== data);\n    }\n\n    /**\n     * Returns snippet from registry that matches given name\n     * @param {String} name\n     * @return {Snippet}\n     */\n    resolve(name) {\n        for (let i = 0; i < this._registry.length; i++) {\n            const snippet = this._registry[i].store.get(name);\n            if (snippet) {\n                return snippet;\n            }\n        }\n    }\n\n    /**\n     * Returns all available snippets from current registry. Snippets with the\n     * same key are resolved by their storage priority.\n     * @param {Object} options\n     * @param {Object} options.type Return snippets only of given type: 'string'\n     * or 'regexp'. Returns all snippets if not defined\n     * @return {Array}\n     */\n    all(options) {\n        options = options || {};\n        const result = new Map();\n\n        const fillResult = snippet => {\n            const type = snippet.key instanceof RegExp ? 'regexp' : 'string';\n            if ((!options.type || options.type === type) && !result.has(snippet.key)) {\n                result.set(snippet.key, snippet);\n            }\n        };\n\n        this._registry.forEach(item => {\n            item.store.values().forEach(fillResult);\n        });\n\n        return Array.from(result.values());\n    }\n\n    /**\n     * Removes all stores from registry\n     */\n    clear() {\n        this._registry.length = 0;\n    }\n}\n\nexport default SnippetsRegistry;\n","/**\n * @type {EmmetOutputProfile}\n */\nvar defaultOptions = {\n\tindent: '\\t',\n\ttagCase: '',\n\tattributeCase: '',\n\tattributeQuotes: 'double',\n\tformat: true,\n\tformatSkip: ['html'],\n\tformatForce: ['body'],\n\tinlineBreak: 3,\n\tcompactBooleanAttributes: false,\n\tbooleanAttributes: ['contenteditable', 'seamless', 'async', 'autofocus',\n\t\t'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n\t\t'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n\t\t'required', 'reversed', 'selected', 'typemustmatch'],\n\tselfClosingStyle: 'html',\n\tinlineElements: ['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n\t\t'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n\t\t'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n\t\t's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n\t\t'textarea', 'tt', 'u', 'var']\n};\n\n/**\n * Creates output profile for given options\n */\nclass Profile {\n\t/**\n\t * @param {EmmetOutputProfile} options \n\t */\n    constructor(options) {\n\t\t/** @type {EmmetOutputProfile} */\n\t\tthis.options = Object.assign({}, defaultOptions, options);\n\t\tthis.quoteChar = this.options.attributeQuotes === 'single' ? '\\'' : '\"';\n    }\n\n\t/**\n\t * Returns value of given option name\n\t * @param {String} name\n\t * @return {*}\n\t */\n\tget(name) {\n\t\treturn this.options[name];\n\t}\n\n    /**\n     * Quote given string according to profile\n     * @param {String} str String to quote\n     * @return {String}\n     */\n    quote(str) {\n        return `${this.quoteChar}${str != null ? str : ''}${this.quoteChar}`;\n    }\n\n    /**\n     * Output given tag name according to options\n     * @param {String} name\n     * @return {String}\n     */\n    name(name) {\n        return strcase(name, this.options.tagCase);\n    }\n\n\t/**\n\t * Outputs attribute name according to current settings\n\t * @param {String} attr Attribute name\n\t * @return {String}\n\t */\n    attribute(attr) {\n        return strcase(attr, this.options.attributeCase);\n    }\n\n    /**\n     * Check if given attribute is boolean\n     * @param {Object} attr\n     * @return {Boolean}\n     */\n    isBooleanAttribute(attr) {\n        return attr.options.boolean\n\t\t\t|| this.get('booleanAttributes').indexOf((attr.name || '').toLowerCase()) !== -1;\n    }\n\n\t/**\n\t * Returns a token for self-closing tag, depending on current options\n\t * @return {String}\n\t */\n\tselfClose() {\n\t\tswitch (this.options.selfClosingStyle) {\n\t\t\tcase 'xhtml': return ' /';\n\t\t\tcase 'xml':   return '/';\n\t\t\tdefault:      return '';\n\t\t}\n\t}\n\n\t/**\n\t * Returns indent for given level\n\t * @param {Number} level Indentation level\n\t * @return {String}\n\t */\n\tindent(level) {\n\t\tlevel = level || 0;\n\t\tlet output = '';\n\t\twhile (level--) {\n\t\t\toutput += this.options.indent;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Check if given tag name belongs to inline-level element\n\t * @param {Object|String} node Parsed node or tag name\n\t * @return {Boolean}\n\t */\n\tisInline(node) {\n        if (typeof node === 'string') {\n            return this.get('inlineElements').indexOf(node.toLowerCase()) !== -1;\n        }\n\n        // inline node is a node either with inline-level name or text-only node\n        return node.name != null ? this.isInline(node.name) : node.isTextOnly;\n\t}\n\n\t/**\n\t * Outputs formatted field for given params\n\t * @param {Number} index Field index\n\t * @param {String} [placeholder] Field placeholder, can be empty\n\t * @return {String}\n\t */\n\tfield(index, placeholder) {\n\t\treturn this.options.field(index, placeholder);\n\t}\n}\nfunction strcase(string, type) {\n    if (type) {\n        return type === 'upper' ? string.toUpperCase() : string.toLowerCase();\n\t}\n\t\n    return string;\n}\n\nexport default Profile;\n","import parseAbbreviation from '@emmetio/abbreviation';\nimport resolveSnippets from '@emmetio/html-snippets-resolver';\nimport transform from '@emmetio/html-transform';\nimport resolveVariables from '@emmetio/variable-resolver';\nimport format from '@emmetio/markup-formatters';\nimport parseAbbreviation$1 from '@emmetio/css-abbreviation';\nimport resolveSnippets$1 from '@emmetio/css-snippets-resolver';\nimport format$1 from '@emmetio/stylesheet-formatters';\nimport defaultSnippets from '@emmetio/snippets';\nimport lorem from '@emmetio/lorem';\nimport SnippetsRegistry from '@emmetio/snippets-registry';\nimport Profile from '@emmetio/output-profile';\n\n/**\n * Expands given abbreviation into code\n * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation\n * @param  {Object} config\n * @return {String}\n */\nfunction expand(abbr, config) {\n\tconfig = Object.assign({}, config);\n\n\tif (typeof abbr === 'string') {\n\t\tabbr = parse(abbr, config);\n\t}\n\n\treturn format(abbr, config.profile, config.syntax, config);\n}\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n * @param {String} Abbreviation to parse\n * @param  {Object} config\n * @return {Node}\n */\nfunction parse(abbr, config) {\n\treturn parseAbbreviation(abbr)\n\t\t.use(resolveSnippets, config.snippets)\n\t\t.use(resolveVariables, config.variables)\n\t\t.use(transform, config.text, config.options);\n}\n\n/**\n * Expands given abbreviation into code\n * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation\n * @param  {Object} config\n * @return {String}\n */\nfunction expand$1(abbr, config) {\n\tconfig = config || {};\n\n\tif (typeof abbr === 'string') {\n\t\tabbr = parse$1(abbr, config);\n\t}\n\n\treturn format$1(abbr, config.profile, config.syntax, config);\n}\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n * @param {String|Node} abbr Abbreviation to parse or already parsed abbreviation\n * @param  {Object} config\n * @return {Node}\n */\nfunction parse$1(abbr, config) {\n\tif (typeof abbr === 'string') {\n\t\tabbr = parseAbbreviation$1(abbr);\n\t}\n\n\treturn abbr.use(resolveSnippets$1, config.snippets, config.options);\n}\n\nconst reLorem = /^lorem([a-z]*)(\\d*)$/i;\n\n/**\n * Constructs a snippets registry, filled with snippets, for given options\n * @param  {String} syntax  Abbreviation syntax\n * @param  {Object|Object[]} snippets Additional snippets\n * @return {SnippetsRegistry}\n */\nfunction snippetsRegistryFactory(type, syntax, snippets) {\n\tconst registrySnippets = [];\n\n\tif (type === 'markup') {\n\t\tregistrySnippets.push(defaultSnippets.html);\n\t} else if (type === 'stylesheet') {\n\t\tregistrySnippets.push(defaultSnippets.css);\n\t}\n\n\tif (syntax in defaultSnippets && registrySnippets.indexOf(defaultSnippets[syntax]) === -1) {\n\t\tregistrySnippets.push(defaultSnippets[syntax]);\n\t}\n\n\tif (Array.isArray(snippets)) {\n\t\tsnippets.forEach(item => {\n\t\t\t// if array item is a string, treat it as a reference to globally\n\t\t\t// defined snippets\n\t\t\tregistrySnippets.push(typeof item === 'string' ? defaultSnippets[item] : item);\n\t\t});\n\t} else if (typeof snippets === 'object') {\n\t\tregistrySnippets.push(snippets);\n\t}\n\n\tconst registry = new SnippetsRegistry(registrySnippets.filter(Boolean));\n\n\t// for non-stylesheet syntaxes add Lorem Ipsum generator\n\tif (type !== 'stylesheet') {\n\t\tregistry.get(0).set(reLorem, loremGenerator);\n\t}\n\n\treturn registry;\n}\n\nfunction loremGenerator(node) {\n\tconst options = {};\n\tconst m = node.name.match(reLorem);\n\tif (m[1]) {\n\t\toptions.lang = m[1];\n\t}\n\n\tif (m[2]) {\n\t\toptions.wordCount = +m[2];\n\t}\n\n\treturn lorem(node, options);\n}\n\n/**\n * Default variables used in snippets to insert common values into predefined snippets\n * @type {Object}\n */\nconst defaultVariables = {\n\tlang: 'en',\n\tlocale: 'en-US',\n\tcharset: 'UTF-8'\n};\n\n/**\n * A list of syntaxes that should use Emmet CSS abbreviations:\n * a variations of default abbreviation that holds values right in abbreviation name\n * @type {Array}\n */\nconst stylesheetSyntaxes = ['css', 'sass', 'scss', 'less', 'stylus', 'sss'];\n\nconst defaultOptions = {\n\t/**\n\t * Type of abbreviation to parse: 'markup' or 'stylesheet'.\n\t * Can be auto-detected from `syntax` property. Default is 'markup'\n\t */\n\ttype: null,\n\n\t/**\n\t * Abbreviation output syntax\n\t * @type {String}\n\t */\n\tsyntax: 'html',\n\n\t/**\n\t * Field/tabstop generator for editor. Most editors support TextMate-style\n\t * fields: ${0} or ${1:item}. So for TextMate-style fields this function\n\t * will look like this:\n\t * @example\n\t * (index, placeholder) => `\\${${index}${placeholder ? ':' + placeholder : ''}}`\n\t *\n\t * @param  {Number} index         Placeholder index. Fields with the same indices\n\t * should be linked\n\t * @param  {String} [placeholder] Field placeholder\n\t * @return {String}\n\t */\n\tfield: (index, placeholder) => placeholder || '',\n\n\t/**\n\t * Insert given text string(s) into expanded abbreviation\n\t * If array of strings is given, the implicitly repeated element (e.g. `li*`)\n\t * will be repeated by the amount of items in array\n\t * @type {String|String[]}\n\t */\n\ttext: null,\n\n\t/**\n\t * Either predefined output profile or options for output profile. Used for\n\t * abbreviation output\n\t * @type {Profile|Object}\n\t */\n\tprofile: null,\n\n\t/**\n\t * Custom variables for variable resolver\n\t * @see @emmetio/variable-resolver\n\t * @type {Object}\n\t */\n\tvariables: {},\n\n\t/**\n\t * Custom predefined snippets for abbreviation. The expanded abbreviation\n\t * will try to match given snippets that may contain custom elements,\n\t * predefined attributes etc.\n\t * May also contain array of items: either snippets (Object) or references\n\t * to default syntax snippets (String; the key in default snippets hash)\n\t * @see @emmetio/snippets\n\t * @type {Object|SnippetsRegistry}\n\t */\n\tsnippets: {},\n\n\t/**\n\t * Hash of additional transformations that should be applied to expanded\n\t * abbreviation, like BEM or JSX. Since these transformations introduce\n\t * side-effect, they are disabled by default and should be enabled by\n\t * providing a transform name as a key and transform options as value:\n\t * @example\n\t * {\n\t *     bem: {element: '--'},\n\t *     jsx: true // no options, just enable transform\n\t * }\n\t * @see @emmetio/html-transform/lib/addons\n\t * @type {Object}\n\t */\n\toptions: null,\n\n\t/**\n\t * Additional options for syntax formatter\n\t * @see @emmetio/markup-formatters\n\t * @type {Object}\n\t */\n\tformat: null\n};\n\n/**\n * Expands given abbreviation into string, formatted according to provided\n * syntax and options\n * @param  {String|Node} abbr       Abbreviation string or parsed abbreviation tree\n * @param  {String|Object} [config] Parsing and formatting options (object) or\n * abbreviation syntax (string)\n * @return {String}\n */\nfunction expand$2(abbr, config) {\n\tconfig = createOptions(config);\n\n\treturn getType(config.type, config.syntax) === 'stylesheet'\n\t\t? expand$1(abbr, config)\n\t\t: expand(abbr, config);\n}\n\n/**\n * Parses given abbreviation into AST tree. This tree can be later formatted to\n * string with `expand` function\n * @param  {String} abbr             Abbreviation to parse\n * @param  {String|Object} [options] Parsing and formatting options (object) or\n * abbreviation syntax (string)\n * @return {Node}\n */\nfunction parse$2(abbr, options) {\n\toptions = createOptions(options);\n\n\treturn getType(options.type, options.syntax) === 'stylesheet'\n\t\t? parse$1(abbr, options)\n\t\t: parse(abbr, options);\n}\n\n/**\n * Creates snippets registry for given syntax and additional `snippets`\n * @param  {String} type     Abbreviation type, 'markup' or 'stylesheet'\n * @param  {String} syntax   Snippets syntax, used for retrieving predefined snippets\n * @param  {SnippetsRegistry|Object|Object[]} [snippets] Additional snippets\n * @return {SnippetsRegistry}\n */\nfunction createSnippetsRegistry(type, syntax, snippets) {\n\t// Backward-compatibility with <0.6\n\tif (type && type !== 'markup' && type !== 'stylesheet') {\n\t\tsnippets = syntax;\n\t\tsyntax = type;\n\t\ttype = 'markup';\n\t}\n\n\treturn snippets instanceof SnippetsRegistry\n\t\t? snippets\n\t\t: snippetsRegistryFactory(type, syntax, snippets);\n}\n\nfunction createOptions(options) {\n\tif (typeof options === 'string') {\n\t\toptions = { syntax: options };\n\t}\n\n\toptions = Object.assign({}, defaultOptions, options);\n\tif (options.type == null && options.syntax) {\n\t\toptions.type = isStylesheet(options.syntax) ? 'stylesheet' : 'markup';\n\t}\n\n\toptions.format = Object.assign({field: options.field}, options.format);\n\toptions.profile = createProfile(options);\n\toptions.variables = Object.assign({}, defaultVariables, options.variables);\n\toptions.snippets = createSnippetsRegistry(options.type, options.syntax, options.snippets);\n\n\treturn options;\n}\n\n/**\n * Check if given syntax belongs to stylesheet markup.\n * Emmet uses different abbreviation flavours: one is a default markup syntax,\n * used for HTML, Slim, Pug etc, the other one is used for stylesheets and\n * allows embedded values in abbreviation name\n * @param  {String}  syntax\n * @return {Boolean}\n */\nfunction isStylesheet(syntax) {\n\treturn stylesheetSyntaxes.indexOf(syntax) !== -1;\n}\n\n/**\n * Creates output profile from given options\n * @param  {Object} options\n * @return {Profile}\n */\nfunction createProfile(options) {\n\treturn options.profile instanceof Profile\n\t\t? options.profile\n\t\t: new Profile(options.profile);\n}\n\n/**\n * Returns type of abbreviation expander: either 'markup' or 'stylesheet'\n * @param {String} type\n * @param {String} [syntax]\n */\nfunction getType(type, syntax) {\n\tif (type) {\n\t\treturn type === 'stylesheet' ? 'stylesheet' : 'markup';\n\t}\n\n\treturn isStylesheet(syntax) ? 'stylesheet' : 'markup';\n}\n\nexport { expand$2 as expand, parse$2 as parse, createSnippetsRegistry, createOptions, isStylesheet, createProfile };\n//# sourceMappingURL=expand.es.js.map\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/*global define, module*/\r\n/**\r\n * TinySort is a small script that sorts HTML elements. It sorts by text- or attribute value, or by that of one of it's children.\r\n * @summary A nodeElement sorting script.\r\n * @version 3.2.0\r\n * @license MIT\r\n * @author Ron Valstar (http://www.ronvalstar.nl/)\r\n * @copyright Ron Valstar <ron@ronvalstar.nl>\r\n * @namespace tinysort\r\n */\r\n(function(root,tinysort){\r\n  typeof define==='function'&&define.amd?define('tinysort',()=>tinysort):(root.tinysort = tinysort)\r\n}(window||module||{},(_undef=>{\r\n  const fls = !1\r\n    ,undef = _undef\r\n    ,nll = null\r\n    ,win = window\r\n    ,doc = win.document\r\n    ,parsefloat = parseFloat\r\n    ,regexLastNr = /(-?\\d+\\.?\\d*)\\s*$/g // regex for testing strings ending on numbers\r\n    ,regexLastNrNoDash = /(\\d+\\.?\\d*)\\s*$/g // regex for testing strings ending on numbers ignoring dashes\r\n    ,plugins = []\r\n    ,largeChar = String.fromCharCode(0xFFF)\r\n    ,/**{options}*/defaults = { // default settings\r\n      selector: nll      // CSS selector to select the element to sort to\r\n      ,order: 'asc'      // order: asc, desc or rand\r\n      ,attr: nll         // order by attribute value\r\n      ,data: nll         // use the data attribute for sorting\r\n      ,useVal: fls       // use element value instead of text\r\n      ,place: 'org'      // place ordered elements at position: start, end, org (original position), first, last\r\n      ,returns: fls      // return all elements or only the sorted ones (true/false)\r\n      ,cases: fls        // a case sensitive sort orders [aB,aa,ab,bb]\r\n      ,natural: fls      // use natural sort order\r\n      ,forceStrings:fls  // if false the string '2' will sort with the value 2, not the string '2'\r\n      ,ignoreDashes:fls  // ignores dashes when looking for numerals\r\n      ,sortFunction: nll // override the default sort function\r\n      ,useFlex:fls\r\n      ,emptyEnd:!fls\r\n      ,console\r\n    }\r\n  let numCriteria = 0\r\n    ,criteriumIndex = 0\r\n\r\n  /**\r\n   * Options object\r\n   * @typedef {object} options\r\n   * @property {string} [selector] A CSS selector to select the element to sort to.\r\n   * @property {string} [order='asc'] The order of the sorting method. Possible values are 'asc', 'desc' and 'rand'.\r\n   * @property {string} [attr=null] Order by attribute value (ie title, href, class)\r\n   * @property {string} [data=null] Use the data attribute for sorting.\r\n   * @property {string} [place='org'] Determines the placement of the ordered elements in respect to the unordered elements. Possible values 'start', 'end', 'first', 'last' or 'org'.\r\n   * @property {boolean} [useVal=false] Use element value instead of text.\r\n   * @property {boolean} [cases=false] A case sensitive sort (orders [aB,aa,ab,bb])\r\n   * @property {boolean} [natural=false] Use natural sort order.\r\n   * @property {boolean} [forceStrings=false] If false the string '2' will sort with the value 2, not the string '2'.\r\n   * @property {boolean} [ignoreDashes=false] Ignores dashes when looking for numerals.\r\n   * @property {function} [sortFunction=null] Override the default sort function. The parameters are of a type {elementObject}.\r\n   * @property {boolean} [useFlex=true] If one parent and display flex, ordering is done by CSS (instead of DOM)\r\n   * @property {boolean} [emptyEnd=true] Sort empty values to the end instead of the start\r\n   * @property {object|boolean} [console] - an optional console implementation to prevent output to console\r\n   */\r\n\r\n  /**\r\n   * TinySort is a small and simple script that will sort any nodeElement by it's text- or attribute value, or by that of one of it's children.\r\n   * @memberof tinysort\r\n   * @public\r\n   * @param {NodeList|HTMLElement[]|String} nodeList The nodelist or array of elements to be sorted. If a string is passed it should be a valid CSS selector.\r\n   * @param {options} [options] A list of options.\r\n   * @returns {HTMLElement[]}\r\n   */\r\n  function tinysort(nodeList,options){\r\n    isString(nodeList) && (nodeList = doc.querySelectorAll(nodeList))\r\n\r\n    const {console} = Object.assign({},defaults,options||{})\r\n    nodeList.length===0 && console && console.warn && console.warn('No elements to sort')\r\n\r\n    const fragment = doc.createDocumentFragment()\r\n      /** both sorted and unsorted elements\r\n       * @type {elementObject[]} */\r\n      ,elmObjsAll = []\r\n      /** sorted elements\r\n       * @type {elementObject[]} */\r\n      ,elmObjsSorted = []\r\n      /** unsorted elements\r\n       * @type {elementObject[]} */\r\n      ,elmObjsUnsorted = []\r\n      /** sorted elements before sort\r\n       * @type {elementObject[]} */\r\n      ,elmObjsSortedInitial = []\r\n      /** @type {criteriumIndex[]} */\r\n      ,criteria = []\r\n    let /** @type {HTMLElement} */parentNode\r\n      ,isSameParent = true\r\n      ,firstParent = nodeList.length&&nodeList[0].parentNode\r\n      ,isFragment = firstParent.rootNode!==document\r\n      ,isFlex = nodeList.length&&(options===undef||options.useFlex!==false)&&!isFragment&&getComputedStyle(firstParent,null).display.indexOf('flex')!==-1\r\n\r\n    initCriteria.apply(nll,Array.prototype.slice.call(arguments,1))\r\n    initSortList()\r\n    elmObjsSorted.sort(options&&options.sortFunction||sortFunction)\r\n    applyToDOM()\r\n\r\n    /**\r\n     * Create criteria list\r\n     */\r\n    function initCriteria(){\r\n      if (arguments.length===0) {\r\n        addCriterium({}) // have at least one criterium\r\n      } else {\r\n        loop(arguments,param=>addCriterium(isString(param)?{selector:param}:param))\r\n      }\r\n      numCriteria = criteria.length\r\n    }\r\n\r\n    /**\r\n     * A criterium is a combination of the selector, the options and the default options\r\n     * @typedef {Object} criterium\r\n     * @property {String} selector - a valid CSS selector\r\n     * @property {String} order - order: asc, desc or rand\r\n     * @property {String} attr - order by attribute value\r\n     * @property {String} data - use the data attribute for sorting\r\n     * @property {boolean} useVal - use element value instead of text\r\n     * @property {String} place - place ordered elements at position: start, end, org (original position), first\r\n     * @property {boolean} returns - return all elements or only the sorted ones (true/false)\r\n     * @property {boolean} cases - a case sensitive sort orders [aB,aa,ab,bb]\r\n     * @property {boolean} natural - use natural sort order\r\n     * @property {boolean} forceStrings - if false the string '2' will sort with the value 2, not the string '2'\r\n     * @property {boolean} ignoreDashes - ignores dashes when looking for numerals\r\n     * @property {Function} sortFunction - override the default sort function\r\n     * @property {boolean} hasSelector - options has a selector\r\n     * @property {boolean} hasFilter - options has a filter\r\n     * @property {boolean} hasAttr - options has an attribute selector\r\n     * @property {boolean} hasData - options has a data selector\r\n     * @property {number} sortReturnNumber - the sort function return number determined by options.order\r\n     */\r\n\r\n    /**\r\n     * Adds a criterium\r\n     * @memberof tinysort\r\n     * @private\r\n     * @param {Object} [options]\r\n     */\r\n    function addCriterium(options){\r\n      const hasSelector = !!options.selector\r\n        ,hasFilter = hasSelector&&options.selector[0]===':'\r\n        ,allOptions = extend(options||{},defaults)\r\n      criteria.push(extend({\r\n        // has find, attr or data\r\n        hasSelector\r\n        ,hasAttr: !(allOptions.attr===nll||allOptions.attr==='')\r\n        ,hasData: allOptions.data!==nll\r\n        // filter\r\n        ,hasFilter\r\n        ,sortReturnNumber: allOptions.order==='asc'?1:-1\r\n      },allOptions))\r\n    }\r\n\r\n    /**\r\n     * The element object.\r\n     * @typedef {Object} elementObject\r\n     * @property {HTMLElement} elm - The element\r\n     * @property {number} pos - original position\r\n     * @property {number} posn - original position on the partial list\r\n     */\r\n\r\n    /**\r\n     * Creates an elementObject and adds to lists.\r\n     * Also checks if has one or more parents.\r\n     * @memberof tinysort\r\n     * @private\r\n     */\r\n    function initSortList(){\r\n      loop(nodeList,(elm,i)=>{\r\n        if (!parentNode) parentNode = elm.parentNode\r\n        else if (parentNode!==elm.parentNode) isSameParent = false\r\n        const {hasFilter,selector} = criteria[0]\r\n          ,isPartial = !selector||(hasFilter&&elm.matches(selector))||(selector&&elm.querySelector(selector))\r\n          ,listPartial = isPartial?elmObjsSorted:elmObjsUnsorted\r\n          ,elementObject = {\r\n            elm: elm\r\n            ,pos: i\r\n            ,posn: listPartial.length\r\n          }\r\n        elmObjsAll.push(elementObject)\r\n        listPartial.push(elementObject)\r\n      })\r\n      elmObjsSortedInitial.splice(0,Number.MAX_SAFE_INTEGER,...elmObjsSorted)\r\n    }\r\n\r\n    /**\r\n     * Compare strings using natural sort order\r\n     * http://web.archive.org/web/20130826203933/http://my.opera.com/GreyWyvern/blog/show.dml/1671288\r\n     */\r\n    function naturalCompare(a, b, chunkify) {\r\n      const aa = chunkify(a.toString())\r\n        ,bb = chunkify(b.toString())\r\n      for (let x = 0; aa[x] && bb[x]; x++) {\r\n        if (aa[x]!==bb[x]) {\r\n          const c = Number(aa[x])\r\n            ,d = Number(bb[x])\r\n          if (c == aa[x] && d == bb[x]) {\r\n            return c - d\r\n          } else return aa[x]>bb[x]?1:-1\r\n        }\r\n      }\r\n      return aa.length - bb.length\r\n    }\r\n\r\n    /**\r\n     * Split a string into an array by type: numeral or string\r\n     * @memberof tinysort\r\n     * @private\r\n     * @param {string} t\r\n     * @returns {Array}\r\n     */\r\n    function chunkify(t) {\r\n      const tz = []\r\n      let x = 0, y = -1, n = 0, i, j\r\n      while (i = (j = t.charAt(x++)).charCodeAt(0)) { // eslint-disable-line no-cond-assign\r\n        const m = (i === 46 || (i >=48 && i <= 57))\r\n        if (m !== n) {\r\n          tz[++y] = ''\r\n          n = m\r\n        }\r\n        tz[y] += j\r\n      }\r\n      return tz\r\n    }\r\n\r\n    /**\r\n     * Sort all the things\r\n     * @memberof tinysort\r\n     * @private\r\n     * @param {elementObject} a\r\n     * @param {elementObject} b\r\n     * @returns {number}\r\n     */\r\n    function sortFunction(a,b){\r\n      let sortReturnNumber = 0\r\n      if (criteriumIndex!==0) criteriumIndex = 0\r\n      while (sortReturnNumber===0&&criteriumIndex<numCriteria) {\r\n        /** @type {criterium} */\r\n        const criterium = criteria[criteriumIndex]\r\n          ,regexLast = criterium.ignoreDashes?regexLastNrNoDash:regexLastNr\r\n        //\r\n        loop(plugins,plugin=>plugin.prepare && plugin.prepare(criterium))\r\n        //\r\n        let isNumeric = fls\r\n          // prepare sort elements\r\n          ,valueA = getSortBy(a,criterium)\r\n          ,valueB = getSortBy(b,criterium)\r\n        if (criterium.sortFunction) { // custom sort\r\n          sortReturnNumber = criterium.sortFunction(a,b)\r\n        } else if (criterium.order==='rand') { // random sort\r\n          sortReturnNumber = Math.random()<0.5?1:-1\r\n        } else { // regular sort\r\n          const noA = valueA===''||valueA===largeChar\r\n            ,noB = valueB===''||valueB===largeChar\r\n          if (valueA===valueB) {\r\n            sortReturnNumber = 0\r\n          } else if (criterium.emptyEnd&&(noA||noB)) {\r\n            sortReturnNumber = noA&&noB?0:noA?1:-1\r\n          } else {\r\n            if (!criterium.forceStrings) {\r\n              // cast to float if both strings are numeral (or end numeral)\r\n              let valuesA = isString(valueA)?valueA&&valueA.match(regexLast):fls// todo: isString superfluous because getSortBy returns string|undefined\r\n                ,valuesB = isString(valueB)?valueB&&valueB.match(regexLast):fls\r\n\r\n              if (valuesA&&valuesB) {\r\n                const previousA = valueA.substr(0,valueA.length-valuesA[0].length)\r\n                  ,previousB = valueB.substr(0,valueB.length-valuesB[0].length)\r\n                if (previousA==previousB) {\r\n                  isNumeric = !fls\r\n                  valueA = parsefloat(valuesA[0])\r\n                  valueB = parsefloat(valuesB[0])\r\n                }\r\n              }\r\n            }\r\n            if (valueA===undef||valueB===undef) {\r\n              sortReturnNumber = 0\r\n            } else {\r\n              // todo: check here\r\n              if (!criterium.natural||(!isNaN(valueA)&&!isNaN(valueB))) {\r\n                sortReturnNumber = valueA<valueB?-1:(valueA>valueB?1:0)\r\n              } else {\r\n                sortReturnNumber = naturalCompare(valueA, valueB, chunkify)\r\n              }\r\n            }\r\n          }\r\n        }\r\n        loop(plugins,({sort})=>sort && (sortReturnNumber = sort(criterium,isNumeric,valueA,valueB,sortReturnNumber)))\r\n        sortReturnNumber *= criterium.sortReturnNumber // lastly assign asc/desc\r\n        sortReturnNumber===0 && criteriumIndex++\r\n      }\r\n      sortReturnNumber===0 && (sortReturnNumber = a.pos>b.pos?1:-1)\r\n      return sortReturnNumber\r\n    }\r\n\r\n    /**\r\n     * Applies the sorted list to the DOM\r\n     * @memberof tinysort\r\n     * @private\r\n     */\r\n    function applyToDOM(){\r\n      const hasSortedAll = elmObjsSorted.length===elmObjsAll.length\r\n      const {place,console} = criteria[0]\r\n      if (isSameParent&&hasSortedAll) {\r\n        if (isFlex) {\r\n          elmObjsSorted.forEach((elmObj,i)=>elmObj.elm.style.order = i)\r\n        } else {\r\n          if (parentNode) parentNode.appendChild(sortedIntoFragment())\r\n          else console && console.warn && console.warn('parentNode has been removed')\r\n        }\r\n      } else {\r\n        const isPlaceOrg = place==='org'\r\n          ,isPlaceStart = place==='start'\r\n          ,isPlaceEnd = place==='end'\r\n          ,isPlaceFirst = place==='first'\r\n          ,isPlaceLast = place==='last'\r\n\r\n        if (isPlaceOrg) {\r\n          elmObjsSorted.forEach(addGhost)\r\n          elmObjsSorted.forEach((elmObj,i)=>replaceGhost(elmObjsSortedInitial[i],elmObj.elm))\r\n        } else if (isPlaceStart||isPlaceEnd) {\r\n          let startElmObj = elmObjsSortedInitial[isPlaceStart?0:elmObjsSortedInitial.length-1]\r\n            ,startParent = startElmObj&&startElmObj.elm.parentNode\r\n            ,startElm = startParent&&(isPlaceStart&&startParent.firstChild||startParent.lastChild)\r\n          if (startElm) {\r\n            startElm!==startElmObj.elm && (startElmObj = {elm:startElm})\r\n            addGhost(startElmObj)\r\n            isPlaceEnd&&startParent.appendChild(startElmObj.ghost)\r\n            replaceGhost(startElmObj,sortedIntoFragment())\r\n          }\r\n        } else if (isPlaceFirst||isPlaceLast) {\r\n          const firstElmObj = elmObjsSortedInitial[isPlaceFirst?0:elmObjsSortedInitial.length-1]\r\n          replaceGhost(addGhost(firstElmObj),sortedIntoFragment())\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Adds all sorted elements to the document fragment and returns it.\r\n     * @memberof tinysort\r\n     * @private\r\n     * @returns {DocumentFragment}\r\n     */\r\n    function sortedIntoFragment(){\r\n      elmObjsSorted.forEach(elmObj=>fragment.appendChild(elmObj.elm))\r\n      return fragment\r\n    }\r\n\r\n    /**\r\n     * Adds a temporary element before an element before reordering.\r\n     * @memberof tinysort\r\n     * @private\r\n     * @param {elementObject} elmObj\r\n     * @returns {elementObject}\r\n     */\r\n    function addGhost(elmObj){\r\n      const element = elmObj.elm\r\n        ,ghost = doc.createElement('div')\r\n      elmObj.ghost = ghost\r\n      element.parentNode.insertBefore(ghost,element)\r\n      return elmObj\r\n    }\r\n\r\n    /**\r\n     * Inserts an element before a ghost element and removes the ghost.\r\n     * @memberof tinysort\r\n     * @private\r\n     * @param {elementObject} elmObjGhost\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function replaceGhost(elmObjGhost,elm){\r\n      const ghost = elmObjGhost.ghost\r\n        ,ghostParent = ghost.parentNode\r\n      ghostParent.insertBefore(elm,ghost)\r\n      ghostParent.removeChild(ghost)\r\n      delete elmObjGhost.ghost\r\n    }\r\n\r\n    /**\r\n     * Get the string/number to be sorted by checking the elementObject with the criterium.\r\n     * @memberof tinysort\r\n     * @private\r\n     * @param {elementObject} elementObject\r\n     * @param {criterium} criterium\r\n     * @returns {String}\r\n     * @todo memoize\r\n     */\r\n    function getSortBy(elementObject,criterium){\r\n      let sortBy\r\n          ,element = elementObject.elm\r\n          ,{selector} = criterium\r\n      // element\r\n      if (selector) {\r\n        if (criterium.hasFilter) {\r\n          if (!element.matches(selector)) element = nll\r\n        } else {\r\n          element = element.querySelector(selector)\r\n        }\r\n      }\r\n      // value\r\n      const getAttribute = element.getAttribute.bind(element)\r\n      if (criterium.hasAttr) sortBy = getAttribute(criterium.attr)\r\n      else if (criterium.useVal) sortBy = element.value||getAttribute('value')\r\n      else if (criterium.hasData) sortBy = getAttribute('data-'+criterium.data)\r\n      else if (element) sortBy = element.textContent\r\n      //\r\n      if (sortBy===nll) {\r\n        sortBy = ''//largeChar\r\n      } else if (isString(sortBy)) { // strings should be ordered in lowercase (unless specified)\r\n        if (!criterium.cases) sortBy = sortBy.toLowerCase()\r\n        sortBy = sortBy.replace(/\\s+/g,' ') // spaces/newlines\r\n      }\r\n      return sortBy\r\n    }\r\n\r\n    /*function memoize(fnc) {\r\n      var oCache = {}\r\n        , sKeySuffix = 0;\r\n      return function () {\r\n        var sKey = sKeySuffix + JSON.stringify(arguments); // todo: circular dependency on Nodes\r\n        return (sKey in oCache)?oCache[sKey]:oCache[sKey] = fnc.apply(fnc,arguments);\r\n      };\r\n    }*/\r\n\r\n    /**\r\n     * Test if an object is a string\r\n     * @memberOf tinysort\r\n     * @method\r\n     * @private\r\n     * @param o\r\n     * @returns {boolean}\r\n     */\r\n    function isString(o){\r\n      return typeof o==='string'\r\n    }\r\n\r\n    return elmObjsSorted.map(o=>o.elm)\r\n  }\r\n\r\n  /**\r\n   * Traverse an array, or array-like object\r\n   * @memberOf tinysort\r\n   * @method\r\n   * @private\r\n   * @param {Array} array The object or array\r\n   * @param {Function} func Callback function with the parameters value and key.\r\n   */\r\n  function loop(array,func){\r\n    const l = array.length\r\n    let i = l\r\n      ,j\r\n    while (i--) {\r\n      j = l-i-1\r\n      func(array[j],j)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extend an object\r\n   * @memberOf tinysort\r\n   * @method\r\n   * @private\r\n   * @param {Object} obj Subject.\r\n   * @param {Object} fns Property object.\r\n   * @param {boolean} [overwrite=false]  Overwrite properties.\r\n   * @returns {Object} Subject.\r\n   */\r\n  function extend(obj,fns,overwrite){\r\n    for (let s in fns) {\r\n      if (overwrite||obj[s]===undef) {\r\n        obj[s] = fns[s]\r\n      }\r\n    }\r\n    return obj\r\n  }\r\n\r\n  function plugin(prepare,sort,sortBy){\r\n    plugins.push({prepare,sort,sortBy})\r\n  }\r\n\r\n  // Element.prototype.matches IE\r\n  win.Element&&(elementPrototype=>elementPrototype.matches = elementPrototype.matches||elementPrototype.msMatchesSelector)(Element.prototype)\r\n\r\n  // extend the plugin to expose stuff\r\n  extend(plugin,{loop})\r\n\r\n  return extend(tinysort,{plugin,defaults})\r\n})()))","/* global QUnit, zenLi, eachElement */\r\nimport tinysort from '../src/tinysort'\r\n\r\nconst {module,test,ok,/*assert,async*/} = QUnit\r\n  ,aList = ['eek-','oif-','myr-','aar-','oac-','eax-']\r\n  ,sJoin = aList.slice(0).sort().join('')\r\n\r\nmodule('es6 import')\r\n\r\ntest('es6 import',()=>{\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*6',{a:aList}))\r\n      ,sSorted = eachElement(aSorted,elm=>elm.textContent)\r\n    return sSorted===sJoin\r\n  })(),'tinysort(nodeList);')\r\n})","/* global QUnit, zenLi, $ */\r\nimport {loadScript} from '../doc/js/util'\r\n\r\nconst {module,test,ok,/*assert,*/async} = QUnit\r\n  ,aList = ['eek-','oif-','myr-','aar-','oac-','eax-']\r\n  ,sJoin = aList.slice(0).sort().join('')\r\n\r\nmodule('jquery plugin wrapper')\r\n\r\ntest('jquery plugin wrapper',()=>{\r\n  const done = async()\r\n  Promise.resolve()\r\n      .then(loadScript.bind(null,'https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'))\r\n      .then(loadScript.bind(null,'/dist/jquery.tinysort.js'))\r\n      .then(()=>{\r\n        ok(!!$.fn.tinysort,'$.fn.tinysort exists')\r\n        ok(!!$.fn.tsort,'tsort alias exists')\r\n        ok((()=>{\r\n          const aNodeList = zenLi('ul>li{a$}*6',{a: aList})\r\n              ,$NodeList = $(aNodeList)\r\n          return !!$NodeList.tsort\r\n        })(),'tsort exists on selection')\r\n        ok((()=>{\r\n          const aNodeList = zenLi('ul>li{a$}*6',{a: aList})\r\n              ,$NodeList = $(aNodeList)\r\n              ,aSorted = $NodeList.tsort()\r\n          return Array.from(aSorted).map(elm=>elm.textContent).join('')===sJoin\r\n        })(),'basic sort')\r\n        done()\r\n      })\r\n})","/* global QUnit, zenLi, eachElement, tinysort */\r\n\r\n// import {loadScript} from '../doc/js/util'\r\n\r\nconst {module,test,ok,/*assert,async*/} = QUnit\r\n  ,aLangSR = ['džep','luđak','čovjek','gospodin','muškarac','ljubav','coga','zec','čega','liljana','godina','nož','njuška']\r\n  ,aLangDA = ['Åben','Æble','Åse','København','Aarhus','Øresund']\r\n  ,aLangFR = ['Ésdf','ésdf','zsdf','Zsdf','Asdf','asdf']\r\n\r\nmodule('charorder plugin')\r\ntest('non latin characters plugin', function() {\r\n\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*'+aLangSR.length,{a:aLangSR}),{charOrder:'cčćd{dž}đl{lj}n{nj}sšzž'})\r\n      ,sSorted = eachElement(aSorted,elm=>' '+elm.textContent)\r\n    return sSorted==' coga čega čovjek džep godina gospodin liljana luđak ljubav muškarac nož njuška zec'\r\n  })(),'tinysort(nodeList,{charOrder:\\'cčćd{dž}đl{lj}n{nj}sšzž\\'}); // Serbo-Croatian')\r\n\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*'+aLangDA.length,{a:aLangDA}),{charOrder:'æøå[{Aa}]'})\r\n      ,sSorted = eachElement(aSorted,elm=>' '+elm.textContent)\r\n    return sSorted==' København Æble Øresund Åben Aarhus Åse'\r\n  })(),'tinysort(nodeList,{charOrder:\\'æøå[{Aa}]\\'}); // Danisch')\r\n\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*'+aLangFR.length,{a:aLangFR}),{charOrder:'a[àâ]c[ç]e[éèêë]i[ïî]o[ôœ]u[ûù]'})\r\n      ,sSorted = eachElement(aSorted,elm=>' '+elm.textContent)\r\n    return sSorted===' Asdf asdf Ésdf ésdf zsdf Zsdf'\r\n  })(),'tst')\r\n\r\n  //console.log('',eachElement(zenLi('ul>li{a$}*'+aLangDA.length,{a:aLangDA}),function(elm){ return ' '+elm.textContent; })); // log\r\n  /*ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*'+aLangDA.length,{a:aLangDA}),{charOrder:'æøå[{Aa}]'})\r\n      ,sSorted = eachElement(aSorted,function(elm){ return ' '+elm.textContent; });\r\n    return sSorted==' København Æble Øresund Åben Aarhus Åse';\r\n  })(),'tinysort(nodeList,{charOrder:\\'a[àâ]c[ç]e[éèêë]i[ïî]o[ôœ]u[ûù]\\'}); // French');*/\r\n})\r\n\r\n// test('charorder AMD', ()=>{\r\n//   const done = async()\r\n//   /*global requirejs, require*/\r\n//   loadScript('https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.15/require.min.js')\r\n//       .then(()=>{\r\n//         console.log('requirejs',!!requirejs,!!require) // todo: remove log\r\n//         require.config({baseUrl: 'dist'})\r\n//         requirejs(['tinysort','tinysort.charorder'],sort=>{\r\n//           ok(!!sort.defaults.hasOwnProperty('charOrder'),'test AMD functionality with RequireJS')\r\n//           done()\r\n//         })\r\n//       })\r\n// })","/* global QUnit, zenLi, eachElement, tinysort */\r\n\r\nconst {module,test,ok} = QUnit\r\n  ,aList = ['eek-','oif-','myr-','aar-','oac-','eax-']\r\n  ,sJoin = aList.slice(0).sort().join('')\r\n\r\nmodule('regression')\r\ntest('issue 8', ()=>{\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*13',{a:['Q','R','S','T','U','V','W','X','Y','Z','Å','Ä','Ö']}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='QRSTUVWXYZÄÅÖ'\r\n  })(),'fixed using new')\r\n})\r\ntest('issue 10', ()=>{\r\n  ok((()=>{\r\n    const aNodes = zenLi('ul>li#a${a}*6',{a:aList})\r\n    aNodes[2].removeAttribute('id')\r\n    const aSorted = tinysort(aNodes)\r\n    const sSorted = eachElement(aSorted,function(elm){return elm.getAttribute('id')||''})\r\n    return sSorted==='eek-oif-aar-oac-eax-'\r\n  })())\r\n})\r\ntest('issue 13', ()=>{\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*6',{a:['eEk-','oif-','myr-','aar-','oac-','eax-']}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='aar-eax-eEk-myr-oac-oif-'\r\n  })(),'regular order')\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*6',{a:['eEk-','oif-','myr-','aar-','oac-','eax-']}),{cases:true})\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='aar-eEk-eax-myr-oac-oif-'\r\n  })(),'case sensitive order')\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*6',{a:aList}),{sortFunction:function(a,b){\r\n        const aa = a[0], bb = b[0]\r\n        return aa==bb?0:(aa>bb?1:-1)\r\n      }})\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='eek-oif-myr-aar-oac-eax-'\r\n  })(),'custom sort function')\r\n})\r\ntest('issue 14', ()=>{\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li[data-foo=a$]{_a$}*6',{a:aList}),{data:'foo'})\r\n      ,sSorted = eachElement(aSorted,function(elm){return elm.getAttribute('data-foo')})\r\n    return sSorted===sJoin\r\n  })(),'implement data-attribute support')\r\n})\r\ntest('issue 15', ()=>{\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*5',{a:['01','001','a','0a','ba']}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='010010aaba'\r\n  })(),'implementation of forceStrings')\r\n})\r\ntest('issue 24', ()=>{\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*5',{a:[20,0,-30,40,-120]}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='-120-3002040'\r\n  })(),'negative numeral value bug')\r\n})\r\ntest('issue 27', ()=>{\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li[data-foo=a$]{_a$}*8',{a:[20,0,-30,20.5,'a','a01',40,-120]}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='_-120_-30_0_20_20.5_40_a_a01'\r\n  })(),'data integer bug')\r\n})\r\ntest('issue 39', ()=>{\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li[value=a$]{_a$}*6',{a:[0,5,1,4,2,3]}),{attr:'value'})\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='_0_1_2_3_4_5'\r\n  })(),'regexp match onto number bug')\r\n})\r\ntest('issue 41', ()=>{\r\n  ok((()=>{\r\n    const aList = ['érythrée','égypte','espagne','estonie','émirats arabes unis','équateur','états-unis','éthiopie']\r\n      ,aSorted = tinysort(zenLi('ul>li{_a$}*'+aList.length,{a:aList}),{charOrder:'a[àâ]c[ç]e[éèêë]i[ïî]o[ôœ]u[ûù]'})\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='_égypte_émirats arabes unis_équateur_érythrée_espagne_estonie_états-unis_éthiopie'\r\n  })(),'French')\r\n})\r\n/*test('issue 44', ()=>{\r\n  ok((()=>{\r\n    const aTest = ['adi95yqw31','eiw19ewe55','eiw73ewe133','eiw99ewe84','eiw9ewe42','eiw9ewe51','eiw9ewe98','jua21soa68','wau147oic54']\r\n      ,aSorted = tinysort(zenLi('ul>li{_a$}*'+aTest.length,{a:aTest}))\r\n      ,sSorted = eachElement(aSorted);\r\n    console.log('sSorted',sSorted); // log\r\n    return sSorted==='_adi95yqw31_eiw9ewe42_eiw9ewe51_eiw9ewe98_eiw19ewe55_eiw73ewe133_eiw99ewe84_jua21soa68_wau147oic54';\r\n  })(),'mixed literal and numeral');\r\n});*/\r\ntest('issue 51', ()=>{\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{_a$}*6',{a:[' 0 ',' 5 ',' 1 ',' 4 ',' 2 ',' 3 ']}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='_ 0 _ 1 _ 2 _ 3 _ 4 _ 5 '\r\n  })(),'numeral values with leading and trailing spaces')\r\n})\r\ntest('issue 62', ()=>{\r\n  ok((()=>{\r\n    const aList = ['érythrée','égypte',2345,'estonie',9876,'équateur','états-unis','éthiopie']\r\n      ,aSorted = tinysort(zenLi('ul>li{_a$}*'+aList.length,{a:aList}),{charOrder:'a[àâ]c[ç]e[éèêë]i[ïî]o[ôœ]u[ûù]'})\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='_égypte_équateur_érythrée_estonie_états-unis_éthiopie_2345_9876'\r\n  })(),'French')\r\n})\r\ntest('issue 76', ()=>{\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li[data-foo=$]*9'))\r\n      ,sSorted = eachElement(aSorted,function(elm){return '_'+elm.getAttribute('data-foo')})\r\n    return sSorted==='_1_2_3_4_5_6_7_8_9'\r\n  })(),'keep original order for same order values (9)')\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li[data-foo=$]*11'))\r\n      ,sSorted = eachElement(aSorted,function(elm){return '_'+elm.getAttribute('data-foo')})\r\n    return sSorted==='_1_2_3_4_5_6_7_8_9_10_11'\r\n  })(),'keep original order for same order values (11)')\r\n})\r\ntest('issue 77', ()=>{\r\n  ok((()=>{\r\n    const aLi = zenLi('ul>li{a $}*6')\r\n    aLi[3].innerHTML = 'a\\n4'\r\n    aLi[1].innerHTML = 'a  2'\r\n    const aSorted = tinysort(aLi)\r\n    const sSorted = eachElement(aSorted)\r\n    return sSorted==='a 1a  2a 3a\\n4a 5a 6'\r\n  })(),'newlines and multiple spaces')\r\n})\r\ntest('issue 78', ()=>{\r\n  ok((()=>{\r\n    const aTest = (function(a,i){\r\n        while (i--) {\r\n          a.push(i)\r\n        }\r\n        return a.sort(function(){return Math.random()<0.5?1:-1})\r\n      })([],14)\r\n      ,aSorted = tinysort(zenLi('ul>li[data-position=a$]{a$}*'+aTest.length,{a:aTest}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='012345678910111213'\r\n  })(),'mixed literal and numeral')\r\n})\r\ntest('issue 113', ()=>{\r\n  ok((()=>{\r\n    const fragment = document.createDocumentFragment()\r\n    let i = 6\r\n    while (i--) {\r\n      const li = document.createElement('li')\r\n      li.innerText = i\r\n      fragment.appendChild(li)\r\n    }\r\n    const aSorted = tinysort(fragment.querySelectorAll('li'))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='012345'\r\n  })(),'empty selector')\r\n})\r\ntest('issue 114', ()=>{\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li.test{_a$}*6',{a:[' 0 ',' 5 ',' 1 ',' 4 ',' 2 ',' 3 ']}),'.test-none')\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted===''\r\n  })(),'empty selector')\r\n})\r\n// todo: write test for #83: https://github.com/Sjeiti/TinySort/issues/83\r\n/*test('issue 86', ()=>{\r\n  ok((()=>{\r\n    const aList = ['Βέλγιο','Βανουάτου','Βατικανό','Βενεζουέλα','Βερμούδες','Βιετνάμ','Βολιβία','Βοσνία και Ερζεγοβίνη','Βουλγαρία','Βραζιλία','Βρετανικές Παρθένοι Νήσοι','Βρετανικό Έδαφος Ανταρκτικής','Βρετανικό Έδαφος του Ινδικού Ωκεανού','Βόρεια Αμερική','Βόρεια Κορέα']\r\n      ,aSorted = tinysort(zenLi('ul>li{_a$}*'+aList.length,{a:aList}),{charOrder:'α[ά]βγδε[έ]ζη[ή]θι[ίϊΐ]κλμνξο[ό]πρστυ[ύϋΰ]φχψω[ώ]'})\r\n      ,sSorted = eachElement(aSorted);\r\n//      console.log('sSorted\\n\\t',sSorted,'\\n\\t','_'+aList.join('_')); // log\r\n    return sSorted==='_Βανουάτου_Βατικανό_Βέλγιο_Βενεζουέλα_Βερμούδες_Βιετνάμ_Βολιβία_Βοσνία και Ερζεγοβίνη_Βουλγαρία_Βραζιλία_Βρετανικές Παρθένοι Νήσοι_Βρετανικό Έδαφος Ανταρκτικής_Βρετανικό Έδαφος του Ινδικού Ωκεανού_Βόρεια Αμερική_Βόρεια Κορέα';\r\n  })(),'Greek');\r\n});*/\r\ntest('issue 116', ()=>{\r\n  ok((()=>{\r\n    const ul = document.createElement('ul')\r\n    ul.innerHTML = `\r\n      <li><span>1</span></li>\r\n      <li><span data-mod=\"c\">3</span>c</li>\r\n      <li><span>5</span></li>\r\n      <li><span>7</span></li>\r\n      <li><span data-mod=\"b\">0</span>b</li>\r\n      <li><span>4</span></li>\r\n      <li><span data-mod=\"a\">9</span>a</li>`\r\n    const aSorted = tinysort(ul.querySelectorAll('li'),{\r\n        selector: 'span'\r\n        ,data: 'mod'\r\n      },{})\r\n      ,sSorted = eachElement(aSorted)\r\n    console.log('sSorted',sSorted) // todo: remove log\r\n    return sSorted==='9a0b3c1457'\r\n  })(),'empty selector')\r\n})\r\n\r\ntest('issue 122', ()=>{\r\n\r\n  // const aLangSR = ['džep','luđak','čovjek','gospodin','muškarac','ljubav','coga','zec','čega','liljana','godina','nož','njuška']\r\n  // const orderSR = 'cčćd{dž}đl{lj}n{nj}sšzž'\r\n  // const ordered = ' coga čega čovjek džep godina gospodin liljana luđak ljubav muškarac nož njuška zec'\r\n  // const reverse = ' '+ordered.substr(1).split(' ').reverse().join(' ')\r\n\r\n  /*ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*'+aLangSR.length,{a:aLangSR}),{charOrder:orderSR})\r\n      ,sSorted = eachElement(aSorted,elm=>' '+elm.textContent)\r\n    return sSorted==ordered\r\n  })(),'normal')\r\n\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*'+aLangSR.length,{a:aLangSR}),{charOrder:orderSR,order:'asc'})\r\n      ,sSorted = eachElement(aSorted,elm=>' '+elm.textContent)\r\n    return sSorted==ordered\r\n  })(),'ascending order')\r\n\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*'+aLangSR.length,{a:aLangSR}),{charOrder:orderSR,order:'desc'})\r\n      ,sSorted = eachElement(aSorted,elm=>' '+elm.textContent)\r\n    return sSorted==reverse\r\n  })(),'descending order')\r\n\r\n  ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*4',{a:'đačb'.split('')}),{charOrder:'ađč'})\r\n      ,sSorted = aSorted.map(elm=>elm.textContent).join('')\r\n    return sSorted=='ađčb'\r\n  })(),'normal charorder')*/\r\n\r\n  ok((()=>{\r\n    window.foo=true;\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*4',{a:'đačb'.split('')}),{charOrder:'ađč',order:'desc'})\r\n      ,sSorted = aSorted.map(elm=>elm.textContent).join('')\r\n    return sSorted=='bčđa'\r\n  })(),'descending charorder')\r\n})\r\n\r\ntest('issue 139', ()=>{\r\n\r\n  const getLiFrom = listring=>{\r\n    const ul = document.createElement('ul')\r\n    ul.innerHTML = listring\r\n    return ul.querySelectorAll('li')\r\n  }\r\n\r\n  /*ok((()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*4',{a:'đačb'.split('')}),{charOrder:'ađč'})\r\n      ,sSorted = aSorted.map(elm=>elm.textContent).join('')\r\n    return sSorted=='ađčb'\r\n  })(),'normal charorder')*/\r\n\r\n  ok((()=>{\r\n    const aSorted = tinysort(getLiFrom('<li>c</li><li foo=\"a\">a</li><li foo=\"\">b</li><li foo>e</li>'),{attr:'foo',emptyEnd:true})\r\n      ,sSorted = aSorted.map(elm=>elm.textContent).join('')\r\n    return sSorted=='acbe'\r\n  })(),'normal attribute order')\r\n\r\n  ok((()=>{\r\n    const aSorted = tinysort(getLiFrom('<li>c</li><li foo=\"a\">a</li><li foo=\"\">b</li><li foo>e</li>'),{attr:'foo',emptyEnd:false})\r\n      ,sSorted = aSorted.map(elm=>elm.textContent).join('')\r\n    return sSorted=='cbea'\r\n  })(),'normal attribute order empty end')\r\n\r\n  ok((()=>{\r\n    const aSorted = tinysort(getLiFrom('<li>c</li><li foo>a</li><li>b</li><li>e</li>'),{attr:'foo',emptyEnd:true})\r\n      ,sSorted = aSorted.map(elm=>elm.textContent).join('')\r\n    console.log('sSorted',sSorted) // todo: remove log\r\n    return sSorted=='acbe'\r\n  })(),'normal attribute order')\r\n\r\n  ok((()=>{\r\n    const aSorted = tinysort(getLiFrom('<li>c</li><li foo>a</li><li>b</li><li>e</li>'),{attr:'foo',emptyEnd:false})\r\n      ,sSorted = aSorted.map(elm=>elm.textContent).join('')\r\n    console.log('sSorted',sSorted) // todo: remove log\r\n    return sSorted=='cbea'\r\n  })(),'normal attribute order empty end')\r\n\r\n})\r\n\r\n\r\n\r\n","/* globals QUnit, zen, zenLi, eachElement, tinysort */ //expect\r\n\r\nconst {module,test,ok/*,assert,async*/} = QUnit\r\n  ,aList = ['eek-','oif-','myr-','aar-','oac-','eax-']\r\n  ,sJoin = aList.slice(0).sort().join('')\r\n  ,sHfJn = aList.slice(0,4).sort().join('')\r\n  ,sSRvr = aList.slice(0).sort().reverse().join('')\r\n\r\nmodule('TinySort')\r\ntest('default functionality', ()=>{\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*6',{a:aList}))\r\n      ,sSorted = eachElement(aSorted,elm=>elm.textContent)\r\n    return sSorted===sJoin\r\n  })(),'tinysort(nodeList);')\r\n  ok( (()=>{\r\n    const mList = zen('ul>li{a$}*6',{a:aList})\r\n    mList.style.display = 'none'\r\n    document.body.appendChild(mList)\r\n    const aSorted = tinysort('ul>li')\r\n      ,sSorted = eachElement(aSorted,elm=>elm.textContent)\r\n    document.body.removeChild(mList)\r\n    return sSorted===sJoin\r\n  })(),'tinysort(string);')\r\n  ok( (()=>{\r\n    const aNodes = zenLi('ul>li{a$}*6',{a:aList})\r\n      ,aArray = []\r\n    let iNodes = aNodes.length\r\n    while (iNodes--) {\r\n      aArray.unshift(aNodes[iNodes])\r\n    }\r\n    const aSorted = tinysort(aArray)\r\n    const sSorted = eachElement(aSorted,elm=>elm.textContent)\r\n    return sSorted===sJoin\r\n  })(),'tinysort(Array);')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li#a${a}*6',{a:aList}),{attr:'id'})\r\n      ,sSorted = eachElement(aSorted,elm=>elm.getAttribute('id'))\r\n    return sSorted===sJoin\r\n  })(),'tinysort(nodeList,{attr:\\'id\\'});')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li*6>(p{$}+p{a$})',{a:aList}),'p:nth-child(2)')\r\n      ,sSorted = eachElement(aSorted,elm=>elm.querySelector('p:nth-child(2)').textContent)\r\n    return sSorted===sJoin\r\n  })(),'tinysort(nodeList,\\'p:nth-child(2)\\');')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li*6>p[title=a$]{a}',{a:aList}),{selector:'p[title]',attr:'title'})\r\n      ,sSorted = eachElement(aSorted,elm=>elm.querySelector('p').getAttribute('title') )\r\n    return sSorted===sJoin\r\n  })(),'tinysort(nodeList,{selector:\\'p[title]\\',attr:\\'title\\'});')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>(li>input[value=a$]+li>select>option[value=b$])*3',{a:aList.slice(0,3),b:aList.slice(3)}),{selector:'input,select',useVal:true})\r\n      ,sSorted = eachElement(aSorted,elm=>elm.querySelector('input,select').value )\r\n    return sSorted===sJoin\r\n  })(),'tinysort(nodeList,{selector:\\'input,select\\',useVal:true})')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li[value=a$]*'+aList.length,{a:aList}),{useVal:true})\r\n      ,sSorted = eachElement(aSorted,elm=>elm.getAttribute('value') )\r\n    return sSorted===sJoin\r\n  })(),'tinysort(nodeList,{useVal:true})')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li[data-foo=a$]{_a$}*6',{a:aList}),{data:'foo'})\r\n      ,sSorted = eachElement(aSorted,elm=>elm.getAttribute('data-foo') )\r\n    return sSorted===sJoin\r\n  })(),'tinysort(nodeList,\\'li\\',{data:\\'foo\\'})')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*6',{a:aList}),':nth-child(-n+4)',{returns:true})\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted===sHfJn\r\n  })(),'tinysort(nodeList,{returns:true});')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*6',{a:aList}),{order:'desc'})\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted===sSRvr\r\n  })(),'tinysort(nodeList,{order:\\'desc\\'});')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*5',{a:[6,1,5,2,4]}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='12456'\r\n  })(),'tinysort(nodeList); with integers')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*5',{a:[4.6,3.1,2.5,5.2,7.4]}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='2.53.14.65.27.4'\r\n  })(),'tinysort(nodeList); with floats')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*3',{a:[123,1.23,12.3]}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='1.2312.3123'\r\n  })(),'tinysort(nodeList); mixed float and integers')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*6',{a:['123 ','1.23 ','12.3 ','1 ','2 ','3 ']}))\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='1 1.23 2 3 12.3 123 '\r\n  })(),'tinysort(nodeList); mixed float and integers suffixed space')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*15',{a:[4.6,'c',7.4,6,'a',11,1,5,3.1,'d',2.5,5.2,'b',2,4]}))\r\n      ,sSorted = eachElement(aSorted,elm=>' '+elm.textContent )\r\n    return sSorted===' 1 2 2.5 3.1 4 4.6 5 5.2 6 7.4 11 a b c d'\r\n  })(),'tinysort(nodeList); mixed types')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*15',{a:[4.6,'c',7.4,6,'a',11,1,5,3.1,'d',2.5,5.2,'b',2,4]}),{forceStrings:true})\r\n      ,sSorted = eachElement(aSorted,elm=>' '+elm.textContent )\r\n    return sSorted===' 1 11 2 2.5 3.1 4 4.6 5 5.2 6 7.4 a b c d'\r\n  })(),'tinysort(nodeList,{forceStrings:true}); mixed types')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{b$}*4',{b:['a11','a1.1','a1','a7']}))\r\n      ,sSorted = eachElement(aSorted,elm=>' '+elm.textContent )\r\n    return sSorted===' a1 a1.1 a7 a11'\r\n  })(),'tinysort(nodeList); mixed numeral/literal')\r\n\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{b$}*5',{b:['11','1','3a','10','1a']}),{natural:true})\r\n      ,sSorted = eachElement(aSorted,elm=>' '+elm.textContent )\r\n    return sSorted===' 1 1a 3a 10 11'\r\n  })(),'tinysort(nodeList,{natural:true}); mixed numeral/literal natural sort')\r\n\r\n  // ok( (()=>{\r\n  //   var aSorted = tinysort(zenLi('ul>(li>span{a$}+li>span.striked{b$})*3',{a:aList.slice(0,3),b:aList.slice(3)}),'span:not([class=striked])',{returns:true,place:'org'})\r\n  //     ,sSorted = aSorted[0].parentNode.textContent+aSorted.length;//eachs(aSorted,function(elm){ return ' '+elm.textContent; });\r\n  //   return sSorted==='eek-aar-myr-oac-oif-eax-3';\r\n  // })(),'tinysort(nodeList,\\'span:not([class=striked])\\',{returns:true,place:\\'org\\'}); return only sorted at original position');\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('div>((ul>li{a$}*4)+ul>li{b$}*4)',{a:['a9','a2','a3','a7'],b:['a11','a1.1','a1','a7']}))\r\n      ,sSorted = eachElement(aSorted,function(elm){ return ' '+elm.textContent })\r\n    return sSorted===' a1 a1.1 a2 a3 a7 a7 a9 a11'\r\n  })(),'tinysort(nodeList); multiple parents')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li{a$}*5',{a:['a-2','a-5','a-6','a-4','a-1']}),{ignoreDashes:true})\r\n      ,sSorted = eachElement(aSorted)\r\n    return sSorted==='a-1a-2a-4a-5a-6'\r\n  })(),'tinysort(nodeList,{ignoreDashes:true}); ignore dashes')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li[value=b$]{a$}*4',{a:['c','','b','a'],b:[3,4,2,1]}),{emptyEnd:true})\r\n      ,sSorted = eachElement(aSorted,function(elm){ return elm.getAttribute('value') })\r\n    return sSorted==='1234'\r\n  })(),'tinysort(nodeList,{emptyEnd:true}); empty values to end')\r\n\r\n  ok( (()=>{\r\n    return placeTest('org')==='bachfegd'\r\n  })(),'tinysort(nodeList,{place:\\'org\\'});')\r\n  ok( (()=>{\r\n    return placeTest('start')==='acegbhfd'\r\n  })(),'tinysort(nodeList,{place:\\'start\\'});')\r\n  ok( (()=>{\r\n    return placeTest('end')==='bhfdaceg'\r\n  })(),'tinysort(nodeList,{place:\\'end\\'});')\r\n  ok( (()=>{\r\n    return placeTest('first')==='baceghfd'\r\n  })(),'tinysort(nodeList,{place:\\'first\\'});')\r\n  ok( (()=>{\r\n    return placeTest('last')==='bhfacegd'\r\n  })(),'tinysort(nodeList,{place:\\'last\\'});')\r\n})\r\n\r\ntest('default functionality: multiple criteria', function() {\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li[value=a$]{b$}*8',{a:[12,4,2,3,5,1,11,6],b:['bb','aa','cc','aa','bb','aa','aa','cc']}),{},{useVal:true})\r\n      ,sSorted = eachElement(aSorted,function(elm){ return ' '+elm.textContent+'_'+elm.value })\r\n    return sSorted===' aa_1 aa_3 aa_4 aa_11 bb_5 bb_12 cc_2 cc_6'\r\n  })(),'tinysort(nodeList,{},{useVal:true});')\r\n  ok( (()=>{\r\n    const aSorted = tinysort(zenLi('ul>li#ida${b$}*8',{a:[12,4,2,3,5,1,11,6],b:['bb','aa','cc','aa','bb','aa','aa','cc']}),{},{attr:'id'})\r\n      ,sSorted = eachElement(aSorted,function(elm){ return ' '+elm.textContent+'_'+elm.getAttribute('id') })\r\n    return sSorted===' aa_id1 aa_id3 aa_id4 aa_id11 bb_id5 bb_id12 cc_id2 cc_id6'\r\n  })(),'tinysort(nodeList,{},{attr:\\'id\\'});')\r\n  // ok( (()=>{\r\n  //   const aSorted = tinysort(zenLi('ul>li[title=ida$]*8>(p{b$}+p{c$})',{a:[12,4,2,3,5,1,11,6],b:['aa','cc','aa','bb','aa','aa','bb','cc'],c:['bb','aa','cc','aa','bb','aa','aa','cc']}),'p:nth-child(2)',{attr:'title'})\r\n  //     ,sSorted = eachElement(aSorted,function(elm){ return ' '+elm.textContent+'_'+elm.getAttribute('title') })\r\n  //   return sSorted===' aaaa_id1 bbaa_id3 ccaa_id4 bbaa_id11 aabb_id5 aabb_id12 aacc_id2 cccc_id6'\r\n  // })(),'tinysort(nodeList,\\'p:eq(1)\\',{attr:\\'title\\'});')\r\n})\r\n\r\n// test('default functionality: AMD', function() {\r\n//   var done = async()\r\n//   /*global requirejs*/\r\n//   require.config({baseUrl: '../../src/'})\r\n//   requirejs(['tinysort'],function(sort){\r\n//     ok(!!sort,'test AMD functionality with RequireJS')\r\n//     done()\r\n//   })\r\n// })\r\n\r\nfunction placeTest(place){\r\n  const div = zen('div>(ul>li.a${b$}*4)+ul>li.a${c$}*4',{\r\n    a:'baab'.split('')\r\n      ,b:'bagh'.split('')\r\n      ,c:'fecd'.split('')\r\n  })\r\n  tinysort(div.querySelectorAll('.a'),{place:place})\r\n  return Array.prototype.map.call(div.querySelectorAll('li'),function(li){\r\n    return li.textContent\r\n  }).join('')\r\n}","/*globals QUnit*/\r\nimport {zen,loadScript} from '../doc/js/util'\r\nimport './test-api'\r\nimport './test-regression'\r\nimport './test-charorder'\r\nimport './test-jquerywrapper'\r\nimport './test-import'\r\n\r\nQUnit.config.hidepassed = true\r\nQUnit.config.autostart = false\r\n\r\n// global test methods\r\nObject.assign(window,{\r\n  zenLi: function(){return zen.apply(zen,arguments).querySelectorAll('li')}\r\n  ,eachElement: (nodeList,fn)=>{\r\n    if (fn===undefined) fn = elm=>elm.textContent\r\n    return nodeList.map(fn).join('')\r\n  }\r\n  ,zen\r\n})\r\n\r\n// load scripts (not import because load should work as well)\r\nPromise.all([\r\n  'dist/tinysort.js'\r\n\t,'dist/tinysort.charorder.js'\r\n].map(loadScript)).then(QUnit.start.bind(QUnit))\r\n"],"sourceRoot":""}